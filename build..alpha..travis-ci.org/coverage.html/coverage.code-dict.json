{"/home/travis/build/npmtest/node-npmtest-node-jsdom/test.js":"/* istanbul instrument in package npmtest_node_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/lib.npmtest_node_jsdom.js":"/* istanbul instrument in package npmtest_node_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_jsdom = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_jsdom = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-jsdom && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_jsdom */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_jsdom\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_jsdom.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_jsdom.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_jsdom.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_jsdom.__dirname + '/lib.npmtest_node_jsdom.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom.js":"var fs = require('fs');\nvar path = require('path');\nvar URL = require('url');\n\nvar toFileUrl = require('./jsdom/utils').toFileUrl;\nvar defineGetter = require('./jsdom/utils').defineGetter;\nvar defineSetter = require('./jsdom/utils').defineSetter;\nvar features = require('./jsdom/browser/documentfeatures');\nvar dom = require('./jsdom/living');\nvar browserAugmentation = require('./jsdom/browser/index').browserAugmentation;\nvar domToHtml = require('./jsdom/browser/domtohtml').domToHtml;\nvar VirtualConsole = require('./jsdom/virtual-console');\n\nvar canReadFilesFromFS = !!fs.readFile; // in a browserify environment, this isn't present\n\nvar request = function() { // lazy loading request\n  request = require('request');\n  return request.apply(undefined, arguments);\n}\n\nexports.getVirtualConsole = function (window) {\n  return window._virtualConsole;\n};\nexports.debugMode = false;\n\n// Proxy feature functions to features module.\n['availableDocumentFeatures',\n 'defaultDocumentFeatures',\n 'applyDocumentFeatures'].forEach(function (propName) {\n  defineGetter(exports, propName, function () {\n    return features[propName];\n  });\n  defineSetter(exports, propName, function (val) {\n    return features[propName] = val;\n  });\n});\n\nexports.jsdom = function (html, options) {\n  if (options === undefined) {\n    options = {};\n  }\n  if (options.parsingMode === undefined || options.parsingMode === 'auto') {\n    options.parsingMode = 'html';\n  }\n\n  var browser = browserAugmentation(dom, options);\n  var doc = new browser.HTMLDocument(options);\n\n  if (options.created) {\n    options.created(null, doc.parentWindow);\n  }\n\n  features.applyDocumentFeatures(doc, options.features);\n\n  if (html === undefined) {\n    html = '';\n  }\n  html = String(html);\n  doc.write(html);\n\n  if (doc.close && !options.deferClose) {\n    doc.close();\n  }\n\n  return doc;\n};\n\nexports.jQueryify = exports.jsdom.jQueryify = function (window, jqueryUrl, callback) {\n  if (!window || !window.document) {\n    return;\n  }\n\n  var features = window.document.implementation._features;\n  window.document.implementation._addFeature('FetchExternalResources', ['script']);\n  window.document.implementation._addFeature('ProcessExternalResources', ['script']);\n  window.document.implementation._addFeature('MutationEvents', ['2.0']);\n\n  var scriptEl = window.document.createElement('script');\n  scriptEl.className = 'jsdom';\n  scriptEl.src = jqueryUrl;\n  scriptEl.onload = scriptEl.onerror = function () {\n    window.document.implementation._features = features;\n\n    if (callback) {\n      callback(window, window.jQuery);\n    }\n  };\n\n  window.document.body.appendChild(scriptEl);\n};\n\nexports.env = exports.jsdom.env = function () {\n  var config = getConfigFromArguments(arguments);\n\n  if (config.file && canReadFilesFromFS) {\n    fs.readFile(config.file, 'utf-8', function (err, text) {\n      if (err) {\n        if (config.created) {\n          config.created(err);\n        }\n        if (config.done) {\n          config.done([err]);\n        }\n        return;\n      }\n\n      setParsingModeFromExtension(config, config.file);\n\n      config.html = text;\n      processHTML(config);\n    });\n  } else if (config.html !== undefined) {\n    processHTML(config);\n  } else if (config.url) {\n    handleUrl(config);\n  } else if (config.somethingToAutodetect !== undefined) {\n    var url = URL.parse(config.somethingToAutodetect);\n    if (url.protocol && url.hostname) {\n      config.url = config.somethingToAutodetect;\n      handleUrl(config.somethingToAutodetect);\n    } else if (canReadFilesFromFS) {\n      fs.readFile(config.somethingToAutodetect, 'utf-8', function (err, text) {\n        if (err) {\n          // the toString() test is because in Node.js, there is no proper code for this.\n          // This is fixed in io.js: https://github.com/iojs/io.js/issues/517 so:\n          // TODO: remove when we start requiring io.js\n          if (err.code === 'ENOENT' || err.code === 'ENAMETOOLONG'\n          \t|| (err.toString() == 'Error: Path must be a string without null bytes.')\n          ) {\n            config.html = config.somethingToAutodetect;\n            processHTML(config);\n          } else {\n            if (config.created) {\n              config.created(err);\n            }\n            if (config.done) {\n              config.done([err]);\n            }\n          }\n        } else {\n          setParsingModeFromExtension(config, config.somethingToAutodetect);\n\n          config.html = text;\n          config.url = toFileUrl(config.somethingToAutodetect);\n          processHTML(config);\n        }\n      });\n    } else {\n      config.html = config.somethingToAutodetect;\n      processHTML(config);\n    }\n  }\n\n  function handleUrl() {\n    var options = {\n      uri: config.url,\n      encoding: config.encoding || 'utf8',\n      headers: config.headers || {},\n      proxy: config.proxy || null,\n      jar: config.jar !== undefined ? config.jar : true\n    };\n\n    request(options, function (err, res, responseText) {\n      if (err) {\n        if (config.created) {\n          config.created(err);\n        }\n        if (config.done) {\n          config.done([err]);\n        }\n        return;\n      }\n\n      // The use of `res.request.uri.href` ensures that `window.location.href`\n      // is updated when `request` follows redirects.\n      config.html = responseText;\n      config.url = res.request.uri.href;\n\n      if (config.parsingMode === \"auto\" && (\n        res.headers[\"content-type\"] === \"application/xml\" ||\n        res.headers[\"content-type\"] === \"text/xml\" ||\n        res.headers[\"content-type\"] === \"application/xhtml+xml\")) {\n        config.parsingMode = \"xml\";\n      }\n\n      processHTML(config);\n    });\n  }\n};\n\nexports.serializeDocument = function (doc) {\n  return domToHtml(doc, true);\n};\n\nfunction processHTML(config) {\n  var options = {\n    features: config.features,\n    url: config.url,\n    parser: config.parser,\n    parsingMode: config.parsingMode,\n    created: config.created,\n    resourceLoader: config.resourceLoader\n  };\n\n  if (config.document) {\n    options.referrer = config.document.referrer;\n    options.cookie = config.document.cookie;\n    options.cookieDomain = config.document.cookieDomain;\n  }\n\n  var window = exports.jsdom(config.html, options).parentWindow;\n  var features = JSON.parse(JSON.stringify(window.document.implementation._features));\n\n  var docsLoaded = 0;\n  var totalDocs = config.scripts.length + config.src.length;\n  var readyState = null;\n  var errors = [];\n\n  if (!window || !window.document) {\n    if (config.created) {\n      config.created(new Error('JSDOM: a window object could not be created.'));\n    }\n    if (config.done) {\n      config.done([new Error('JSDOM: a window object could not be created.')]);\n    }\n    return;\n  }\n\n  window.document.implementation._addFeature('FetchExternalResources', ['script']);\n  window.document.implementation._addFeature('ProcessExternalResources', ['script']);\n  window.document.implementation._addFeature('MutationEvents', ['2.0']);\n\n  function scriptComplete() {\n    docsLoaded++;\n\n    if (docsLoaded >= totalDocs) {\n      window.document.implementation._features = features;\n\n      errors = errors.concat(window.document.errors || []);\n      if (errors.length === 0) {\n        errors = null;\n      }\n\n      process.nextTick(function() {\n        if (config.loaded) {\n          config.loaded(errors, window);\n        }\n        if (config.done) {\n          config.done(errors, window);\n        }\n      });\n    }\n  }\n\n  function handleScriptError(e) {\n    if (!errors) {\n      errors = [];\n    }\n    errors.push(e.error || e.message);\n\n    // nextTick so that an exception within scriptComplete won't cause\n    // another script onerror (which would be an infinite loop)\n    process.nextTick(scriptComplete);\n  }\n\n  if (config.scripts.length > 0 || config.src.length > 0) {\n    config.scripts.forEach(function (scriptSrc) {\n      var script = window.document.createElement('script');\n      script.className = 'jsdom';\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.src = scriptSrc;\n\n      try {\n        // protect against invalid dom\n        // ex: http://www.google.com/foo#bar\n        window.document.documentElement.appendChild(script);\n      } catch (e) {\n        handleScriptError(e);\n      }\n    });\n\n    config.src.forEach(function (scriptText) {\n      var script = window.document.createElement('script');\n      script.onload = scriptComplete;\n      script.onerror = handleScriptError;\n      script.text = scriptText;\n\n      window.document.documentElement.appendChild(script);\n      window.document.documentElement.removeChild(script);\n    });\n  } else {\n    if (window.document.readyState === 'complete') {\n      scriptComplete();\n    } else {\n      window.addEventListener('load', function() {\n        scriptComplete();\n      });\n    }\n  }\n}\n\nfunction getConfigFromArguments(args, callback) {\n  var config = {};\n  if (typeof args[0] === 'object') {\n    var configToClone = args[0];\n    Object.keys(configToClone).forEach(function (key) {\n      config[key] = configToClone[key];\n    });\n  } else {\n    var stringToAutodetect = null;\n\n    Array.prototype.forEach.call(args, function (arg) {\n      switch (typeof arg) {\n        case 'string':\n          config.somethingToAutodetect = arg;\n          break;\n        case 'function':\n          config.done = arg;\n          break;\n        case 'object':\n          if (Array.isArray(arg)) {\n            config.scripts = arg;\n          } else {\n            extend(config, arg);\n          }\n          break;\n      }\n    });\n  }\n\n  if (!config.done && !config.created && !config.loaded) {\n    throw new Error('Must pass a \"created\", \"loaded\", \"done\" option or a callback to jsdom.env.');\n  }\n\n  if (config.somethingToAutodetect === undefined &&\n      config.html === undefined && !config.file && !config.url) {\n    throw new Error('Must pass a \"html\", \"file\", or \"url\" option, or a string, to jsdom.env');\n  }\n\n  config.scripts = ensureArray(config.scripts);\n  config.src = ensureArray(config.src);\n  config.parsingMode = config.parsingMode || \"auto\";\n\n  config.features = config.features || {\n    FetchExternalResources: false,\n    ProcessExternalResources: false,\n    SkipExternalResources: false\n  };\n\n  if (!config.url && config.file) {\n    config.url = toFileUrl(config.file);\n  }\n\n  return config;\n}\n\nfunction ensureArray(value) {\n  var array = value || [];\n  if (typeof array === 'string') {\n    array = [array];\n  }\n  return array;\n}\n\nfunction extend(config, overrides) {\n  Object.keys(overrides).forEach(function (key) {\n    config[key] = overrides[key];\n  });\n}\n\nfunction setParsingModeFromExtension(config, filename) {\n  if (config.parsingMode === \"auto\") {\n    var ext = path.extname(filename);\n    if (ext === \".xhtml\" || ext === \".xml\") {\n      config.parsingMode = \"xml\";\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/utils.js":"\"use strict\";\nvar path = require(\"path\");\nvar url = require(\"url\");\n\nexports.toFileUrl = function (fileName) {\n  // Beyond just the `path.resolve`, this is mostly for the benefit of Windows,\n  // where we need to convert \"\\\" to \"/\" and add an extra \"/\" prefix before the\n  // drive letter.\n  var pathname = path.resolve(process.cwd(), fileName).replace(/\\\\/g, \"/\");\n  if (pathname[0] !== \"/\") {\n    pathname = \"/\" + pathname;\n  }\n\n  return \"file://\" + pathname;\n};\n\n/**\n * Define a setter on an object\n *\n * This method replaces any existing setter but leaves getters in place.\n *\n * - `object` {Object} the object to define the setter on\n * - `property` {String} the name of the setter\n * - `setterFn` {Function} the setter\n */\nexports.defineSetter = function defineSetter(object, property, setterFn) {\n  var descriptor = Object.getOwnPropertyDescriptor(object, property) || {\n    configurable: true,\n    enumerable: true\n  };\n\n  descriptor.set = setterFn;\n\n  Object.defineProperty(object, property, descriptor);\n};\n\n/**\n * Define a getter on an object\n *\n * This method replaces any existing getter but leaves setters in place.\n *\n * - `object` {Object} the object to define the getter on\n * - `property` {String} the name of the getter\n * - `getterFn` {Function} the getter\n */\nexports.defineGetter = function defineGetter(object, property, getterFn) {\n  var descriptor = Object.getOwnPropertyDescriptor(object, property) || {\n    configurable: true,\n    enumerable: true\n  };\n\n  descriptor.get = getterFn;\n\n  Object.defineProperty(object, property, descriptor);\n};\n\n/**\n * Create an object with the given prototype\n *\n * Optionally augment the created object.\n *\n * - `prototype` {Object} the created object's prototype\n * - `[properties]` {Object} properties to attach to the created object\n */\nexports.createFrom = function createFrom(prototype, properties) {\n  properties = properties || {};\n\n  var descriptors = {};\n  Object.getOwnPropertyNames(properties).forEach(function (name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(properties, name);\n  });\n\n  return Object.create(prototype, descriptors);\n};\n\n/**\n * Create an inheritance relationship between two classes\n *\n * Optionally augment the inherited prototype.\n *\n * - `Superclass` {Function} the inherited class\n * - `Subclass` {Function} the inheriting class\n * - `[properties]` {Object} properties to attach to the inherited prototype\n */\nexports.inheritFrom = function inheritFrom(Superclass, Subclass, properties) {\n  properties = properties || {};\n\n  Object.defineProperty(properties, \"constructor\", {\n    value: Subclass,\n    writable: true,\n    configurable: true\n  });\n\n  Subclass.prototype = exports.createFrom(Superclass.prototype, properties);\n};\n\n/**\n * Define a list of constants on a constructor and its .prototype\n *\n * - `Constructor` {Function} the constructor to define the constants on\n * - `propertyMap` {Object}  key/value map of properties to define\n */\nexports.addConstants = function addConstants(Constructor, propertyMap) {\n  for (var property in propertyMap) {\n    var value = propertyMap[property];\n    addConstant(Constructor, property, value);\n    addConstant(Constructor.prototype, property, value);\n  }\n};\n\nfunction addConstant(object, property, value) {\n  Object.defineProperty(object, property, {\n    configurable: false,\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n}\n\nvar memoizeQueryTypeCounter = 0;\n\n/**\n * Returns a version of a method that memoizes specific types of calls on the object\n *\n * - `fn` {Function} the method to be memozied\n */\nexports.memoizeQuery = function memoizeQuery(fn) {\n  // Only memoize query functions with arity <= 2\n  if (fn.length > 2) {\n    return fn;\n  }\n\n  var type = memoizeQueryTypeCounter++;\n\n  return function () {\n    if (!this._memoizedQueries) {\n      return fn.apply(this, arguments);\n    }\n\n    if (!this._memoizedQueries[type]) {\n      this._memoizedQueries[type] = Object.create(null);\n    }\n\n    var key;\n    if (arguments.length === 1 && typeof arguments[0] === \"string\") {\n      key = arguments[0];\n    } else if (arguments.length === 2 && typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n      key = arguments[0] + \"::\" + arguments[1];\n    } else {\n      return fn.apply(this, arguments);\n    }\n\n    if (!(key in this._memoizedQueries[type])) {\n      this._memoizedQueries[type][key] = fn.apply(this, arguments);\n    }\n    return this._memoizedQueries[type][key];\n  };\n};\n\n/**\n* A slightly-more-compliant version of `url.resolve`, taking care of a few Node bugs.\n*/\nexports.resolveHref = function resolveHref(baseUrl, href) {\n  var about = \"about:blank\";\n\n  // if we're redirecting to another site on about:blank, just let it through\n  if (href.substring(0, about.length) === about) {\n    return href;\n  }\n\n  // if we have to resolve from about:blank we need a bit of special logic\n  if (baseUrl.substring(0, about.length) === about) {\n    if (href.search(/^([A-Za-z0-9]+):/) === 0) { // we have an absolute url\n      baseUrl = href;\n      href = \"\";\n    } else if (href[0] === \"#\") { // we have a location hash on about:blank\n      return baseUrl.split(/#/)[0] + href;\n    } else if (!href) { // we just have some base url\n      return baseUrl;\n    } else { // must be a file url\n      baseUrl = \"file://\" + href;\n      href = \"\";\n    }\n  }\n\n  if (baseUrl === resolveHref.memoizedUrl && resolveHref.cache && resolveHref.cache[href]) {\n    return resolveHref.cache[href];\n  }\n\n  // When switching protocols, the path doesn't get canonicalized (i.e. .s and ..s are still left):\n  // https://github.com/joyent/node/issues/5453\n  var intermediate = url.resolve(baseUrl, href);\n\n  // This canonicalizes the path, at the cost of overwriting the hash.\n  var nextStep = url.resolve(intermediate, \"#\");\n\n  // But it breaks file URLs by removing their colon O_o, so put that back.\n  nextStep = nextStep.replace(/^file:\\/\\/([a-z])\\//i, \"file:///$1:/\");\n\n  // So, insert the hash back in, if there was one.\n  var parsed = url.parse(intermediate);\n  var fixed = nextStep.slice(0, -1) + (parsed.hash || \"\");\n\n  // Finally, fix file:/// URLs on Windows, where Node removes their drive letters:\n  // https://github.com/joyent/node/issues/5452\n  if (/^file\\:\\/\\/\\/[a-z]\\:\\//i.test(baseUrl) && /^file\\:\\/\\/\\//.test(fixed) &&\n      !/^file\\:\\/\\/\\/[a-z]\\:\\//i.test(fixed)) {\n    fixed = fixed.replace(/^file\\:\\/\\/\\//, baseUrl.substring(0, 11));\n  }\n\n  // HORRIBLE HACK: encode \\u00E4 correctly just so that we pass\n  // https://github.com/w3c/web-platform-tests/blob/e75f01a689a3481f5c773315c2c2527712cf8c2c/dom/nodes/DOMImplementation-createHTMLDocument.html#L71-L72\n  // Eventually we should replace this with a real URL parser based on the URL standard.\n  fixed = fixed.replace(/\\u00E4/, \"%C3%A4\");\n\n  if (baseUrl !== resolveHref.memoizedUrl) {\n    resolveHref.memoizedUrl = baseUrl;\n    resolveHref.cache = {};\n  }\n  resolveHref.cache[href] = fixed;\n\n  return fixed;\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/documentfeatures.js":"exports.availableDocumentFeatures = [\n  'FetchExternalResources',\n  'ProcessExternalResources',\n  'MutationEvents',\n  'SkipExternalResources'\n];\n\nexports.defaultDocumentFeatures = {\n  \"FetchExternalResources\": ['script', 'link'/*, 'img', 'css', 'frame'*/],\n  \"ProcessExternalResources\": ['script'/*, 'frame', 'iframe'*/],\n  \"MutationEvents\": '2.0',\n  \"SkipExternalResources\": false\n};\n\nexports.applyDocumentFeatures = function(doc, features) {\n  var i, maxFeatures = exports.availableDocumentFeatures.length,\n      defaultFeatures = exports.defaultDocumentFeatures,\n      j,\n      k,\n      featureName,\n      featureSource;\n\n  features = features || {};\n\n  for (i=0; i<maxFeatures; i++) {\n    featureName = exports.availableDocumentFeatures[i];\n    if (typeof features[featureName] !== 'undefined') {\n      featureSource = features[featureName];\n    // We have to check the lowercase version also because the Document feature\n    // methods convert everything to lowercase.\n    } else if (typeof features[featureName.toLowerCase()] !== 'undefined') {\n      featureSource = features[featureName.toLowerCase()];\n    } else if (defaultFeatures[featureName]) {\n      featureSource = defaultFeatures[featureName];\n    } else {\n      continue;\n    }\n\n    doc.implementation._removeFeature(featureName);\n\n    if (typeof featureSource !== 'undefined') {\n      if (featureSource instanceof Array) {\n        k = featureSource.length;\n        for (j=0; j<k; j++) {\n          doc.implementation._addFeature(featureName, featureSource[j]);\n        }\n      } else {\n        doc.implementation._addFeature(featureName, featureSource);\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/index.js":"\"use strict\";\nvar core = module.exports = require(\"../level1/core\");\n\n// These (because of how they were written) directly include level1/core and modify it.\n// ORDER IS IMPORTANT\nrequire(\"../level2/core\");\nrequire(\"../level2/events\");\nrequire(\"../level2/html\");\nrequire(\"../level2/style\");\nrequire(\"../level3/core\");\nrequire(\"../level3/ls\");\nrequire(\"../level3/xpath\");\n\nrequire(\"./document-type\")(core);\nrequire(\"./character-data\")(core);\nrequire(\"./processing-instruction\")(core);\nrequire(\"./comment\")(core);\nrequire(\"./text\")(core);\nrequire(\"./dom-implementation\")(core);\nrequire(\"./document\")(core);\nrequire(\"./node-filter\")(core);\nrequire(\"./node\")(core);\nrequire(\"./selectors\")(core);\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level1/core.js":"/*\n  ServerJS Javascript DOM Level 1\n*/\nvar inheritFrom = require(\"../utils\").inheritFrom;\nvar domToHtml = require(\"../browser/domtohtml\").domToHtml;\nvar defineGetter = require(\"../utils\").defineGetter;\nvar memoizeQuery = require(\"../utils\").memoizeQuery;\nvar validateName = require('../living/helpers/validate-names').name;\nvar Location = require(\"../browser/location\");\n\n// utility functions\nvar attachId = function(id,elm,doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n    doc._ids[id].push(elm);\n  }\n};\nvar detachId = function(id,elm,doc) {\n  var elms, i;\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      elms = doc._ids[id];\n      for (i=0;i<elms.length;i++) {\n        if (elms[i] === elm) {\n          elms.splice(i,1);\n          i--;\n        }\n      }\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n};\n\nfunction setInnerHTML(dom, node, html) {\n  //Clear the children first:\n  var child;\n  while ((child = node._childNodes[0])) {\n    node.removeChild(child);\n  }\n\n  var isDoc = node.nodeName === '#document';\n  if (html !== \"\" && html != null) {\n    if (isDoc) {\n      dom._htmlToDom.appendHtmlToDocument(html, node);\n    } else {\n      dom._htmlToDom.appendHtmlToElement(html, node);\n    }\n  }\n}\n\n// TODO: move all of these to utils.js. Right now they are exposed on window, which is bizarre.\nvar core = module.exports = {\n  mapper: function(parent, filter, recursive) {\n    return function() {\n      return core.mapDOMNodes(parent, recursive !== false, filter);\n    };\n  },\n\n  // Returns Array\n  mapDOMNodes : function(parent, recursive, callback) {\n    function visit(parent, result) {\n      return parent._childNodes.reduce(reducer, result);\n    }\n\n    function reducer(array, child) {\n      if (callback(child)) {\n        array.push(child);\n      }\n      if (recursive && child._childNodes) {\n        visit(child, array);\n      }\n      return array;\n    }\n\n    return visit(parent, []);\n  },\n\n  visitTree: function(root, callback) {\n    var cur = root; // TODO: Unroll this.\n\n    function visit(el) {\n      if (el) {\n        callback(el);\n        if (el._childNodes) {\n          var i        = 0,\n              children = el._childNodes,\n              l        = children.length;\n\n          for (i; i<l; i++) {\n            visit(children[i]);\n          }\n        }\n      }\n    }\n    visit(root);\n  },\n\n  markTreeReadonly: function(node) {\n    function markLevel(el) {\n      el._readonly = true;\n      // also mark attributes and their children read-only\n      if (el.attributes) {\n        var attributes = el.attributes, l = attributes.length, i=0;\n        attributes._readonly = true;\n\n        for (i; i<l; i++) {\n          core.visitTree(attributes[i], markLevel);\n        }\n      }\n    }\n\n    core.visitTree(node, markLevel);\n  }\n};\n\n// ExceptionCode\nvar INDEX_SIZE_ERR              = core.INDEX_SIZE_ERR              = 1,\n    DOMSTRING_SIZE_ERR          = core.DOMSTRING_SIZE_ERR          = 2,\n    HIERARCHY_REQUEST_ERR       = core.HIERARCHY_REQUEST_ERR       = 3,\n    WRONG_DOCUMENT_ERR          = core.WRONG_DOCUMENT_ERR          = 4,\n    INVALID_CHARACTER_ERR       = core.INVALID_CHARACTER_ERR       = 5,\n    NO_DATA_ALLOWED_ERR         = core.NO_DATA_ALLOWED_ERR         = 6,\n    NO_MODIFICATION_ALLOWED_ERR = core.NO_MODIFICATION_ALLOWED_ERR = 7,\n    NOT_FOUND_ERR               = core.NOT_FOUND_ERR               = 8,\n    NOT_SUPPORTED_ERR           = core.NOT_SUPPORTED_ERR           = 9,\n    INUSE_ATTRIBUTE_ERR         = core.INUSE_ATTRIBUTE_ERR         = 10,\n    INVALID_STATE_ERR           = core.INVALID_STATE_ERR           = 11,\n    SYNTAX_ERR                  = core.SYNTAX_ERR                  = 12,\n    INVALID_MODIFICATION_ERR    = core.INVALID_MODIFICATION_ERR    = 13,\n    NAMESPACE_ERR               = core.NAMESPACE_ERR               = 14,\n    INVALID_ACCESS_ERR          = core.INVALID_ACCESS_ERR          = 15,\n// Node Types\n    ELEMENT_NODE                = 1,\n    ATTRIBUTE_NODE              = 2,\n    TEXT_NODE                   = 3,\n    CDATA_SECTION_NODE          = 4,\n    ENTITY_REFERENCE_NODE       = 5,\n    ENTITY_NODE                 = 6,\n    PROCESSING_INSTRUCTION_NODE = 7,\n    COMMENT_NODE                = 8,\n    DOCUMENT_NODE               = 9,\n    DOCUMENT_TYPE_NODE          = 10,\n    DOCUMENT_FRAGMENT_NODE      = 11,\n    NOTATION_NODE               = 12;\n\nvar messages = core.exceptionMessages = { };\nmessages[INDEX_SIZE_ERR]              = \"Index size error\";\nmessages[DOMSTRING_SIZE_ERR]          = \"DOMString size error\";\nmessages[HIERARCHY_REQUEST_ERR]       = \"Hierarchy request error\";\nmessages[WRONG_DOCUMENT_ERR]          = \"Wrong document\";\nmessages[INVALID_CHARACTER_ERR]       = \"Invalid character\";\nmessages[NO_DATA_ALLOWED_ERR]         = \"No data allowed\";\nmessages[NO_MODIFICATION_ALLOWED_ERR] = \"No modification allowed\";\nmessages[NOT_FOUND_ERR]               = \"Not found\";\nmessages[NOT_SUPPORTED_ERR]           = \"Not supported\";\nmessages[INUSE_ATTRIBUTE_ERR]         = \"Attribute in use\";\nmessages[NAMESPACE_ERR]               = \"Invalid namespace\";\n\ncore.DOMException = function DOMException(code, message) {\n  Error.call(this, core.exceptionMessages[code]);\n  this.message = core.exceptionMessages[code];\n  this.code = code;\n\n  if (message) {\n    this.message = this.message + \": \" + message;\n  }\n\n  if (Error.captureStackTrace) {\n\n    Error.captureStackTrace(this, DOMException);\n  }\n};\n\ncore.DOMException.INDEX_SIZE_ERR              = INDEX_SIZE_ERR;\ncore.DOMException.DOMSTRING_SIZE_ERR          = DOMSTRING_SIZE_ERR;\ncore.DOMException.HIERARCHY_REQUEST_ERR       = HIERARCHY_REQUEST_ERR;\ncore.DOMException.WRONG_DOCUMENT_ERR          = WRONG_DOCUMENT_ERR;\ncore.DOMException.INVALID_CHARACTER_ERR       = INVALID_CHARACTER_ERR;\ncore.DOMException.NO_DATA_ALLOWED_ERR         = NO_DATA_ALLOWED_ERR;\ncore.DOMException.NO_MODIFICATION_ALLOWED_ERR = NO_MODIFICATION_ALLOWED_ERR;\ncore.DOMException.NOT_FOUND_ERR               = NOT_FOUND_ERR;\ncore.DOMException.NOT_SUPPORTED_ERR           = NOT_SUPPORTED_ERR;\ncore.DOMException.INUSE_ATTRIBUTE_ERR         = INUSE_ATTRIBUTE_ERR;\ncore.DOMException.INVALID_STATE_ERR           = INVALID_STATE_ERR;\ncore.DOMException.SYNTAX_ERR                  = SYNTAX_ERR;\ncore.DOMException.INVALID_MODIFICATION_ERR    = INVALID_MODIFICATION_ERR;\ncore.DOMException.NAMESPACE_ERR               = NAMESPACE_ERR;\ncore.DOMException.INVALID_ACCESS_ERR          = INVALID_ACCESS_ERR;\n\ninheritFrom(Error, core.DOMException, {\n  name: \"DOMException\",\n  INDEX_SIZE_ERR              : INDEX_SIZE_ERR,\n  DOMSTRING_SIZE_ERR          : DOMSTRING_SIZE_ERR,\n  HIERARCHY_REQUEST_ERR       : HIERARCHY_REQUEST_ERR,\n  WRONG_DOCUMENT_ERR          : WRONG_DOCUMENT_ERR,\n  INVALID_CHARACTER_ERR       : INVALID_CHARACTER_ERR,\n  NO_DATA_ALLOWED_ERR         : NO_DATA_ALLOWED_ERR,\n  NO_MODIFICATION_ALLOWED_ERR : NO_MODIFICATION_ALLOWED_ERR,\n  NOT_FOUND_ERR               : NOT_FOUND_ERR,\n  NOT_SUPPORTED_ERR           : NOT_SUPPORTED_ERR,\n  INUSE_ATTRIBUTE_ERR         : INUSE_ATTRIBUTE_ERR,\n  INVALID_STATE_ERR           : INVALID_STATE_ERR,\n  SYNTAX_ERR                  : SYNTAX_ERR,\n  INVALID_MODIFICATION_ERR    : INVALID_MODIFICATION_ERR,\n  NAMESPACE_ERR               : NAMESPACE_ERR,\n  INVALID_ACCESS_ERR          : INVALID_ACCESS_ERR\n});\n\ncore.NodeList = function NodeList(element, query) {\n  if (!query) {\n    // Non-live NodeList\n    if (Array.isArray(element)) {\n      Array.prototype.push.apply(this, element);\n    }\n    Object.defineProperties(this, {\n      _length: {value: element ? element.length : 0, writable:true}\n    });\n  } else {\n    Object.defineProperties(this, {\n      _element: {value: element},\n      _query: {value: query},\n      _snapshot: {writable: true},\n      _length: {value: 0, writable: true},\n      _version: {value: -1, writable: true}\n    });\n    this._update();\n  }\n};\n\nfunction lengthFromProperties(arrayLike) {\n  var max = -1;\n  var keys = Object.keys(arrayLike);\n  var highestKeyIndex = keys.length - 1;\n\n  // abuses a v8 implementation detail for a very fast case\n  // (if this implementation detail changes, this method will still\n  //  return correct results)\n  if (highestKeyIndex == keys[highestKeyIndex]) { // not ===\n    return keys.length;\n  }\n\n  for (var i = highestKeyIndex; i >= 0 ; --i) {\n    var asNumber = + keys[i];\n\n    if (!isNaN(asNumber) && asNumber > max) {\n      max = asNumber;\n    }\n  }\n  return max + 1;\n}\ncore.NodeList.prototype = {\n  _update: function() {\n    var i;\n\n    if (!this._element) {\n      this._length = lengthFromProperties(this);\n    } else {\n      if (this._version < this._element._version) {\n        var nodes = this._snapshot = this._query();\n        this._resetTo(nodes);\n        this._version = this._element._version;\n      }\n    }\n  },\n  _resetTo: function(array) {\n    var startingLength = lengthFromProperties(this);\n    for (var i = 0; i < startingLength; ++i) {\n      delete this[i];\n    }\n\n    for (var j = 0; j < array.length; ++j) {\n      this[j] = array[j];\n    }\n    this._length = array.length;\n  },\n  _toArray: function() {\n    if (this._element) {\n      this._update();\n      return this._snapshot;\n    }\n\n    return Array.prototype.slice.call(this);\n  },\n  get length() {\n    this._update();\n    return this._length || 0;\n  },\n  set length(length) {\n    return this._length;\n  },\n  item: function(index) {\n    this._update();\n    return this[index] || null;\n  },\n  toString: function() {\n    return '[ jsdom NodeList ]: contains ' + this.length + ' items';\n  }\n};\nObject.defineProperty(core.NodeList.prototype, 'constructor', {\n  value: core.NodeList,\n  writable: true,\n  configurable: true\n});\n\ncore.DOMImplementation = function DOMImplementation(document, /* Object */ features) {\n  this._ownerDocument = document;\n  this._features = {};\n\n  if (features) {\n    for (var feature in features) {\n      if (features.hasOwnProperty(feature)) {\n        this._addFeature(feature.toLowerCase(), features[feature]);\n      }\n    }\n  }\n};\n\ncore.DOMImplementation.prototype = {\n  // All of these are legacy, left because jsdom uses them internally :(. jsdom confused the idea of browser features\n  // and jsdom features\n  _removeFeature : function(feature, version) {\n    feature = feature.toLowerCase();\n    if (this._features[feature]) {\n      if (version) {\n        var j        = 0,\n            versions = this._features[feature],\n            l        = versions.length;\n\n        for (j; j<l; j++) {\n          if (versions[j] === version) {\n            versions.splice(j,1);\n            return;\n          }\n        }\n      } else {\n        delete this._features[feature];\n      }\n    }\n  },\n\n  _addFeature: function(feature, version) {\n    feature = feature.toLowerCase();\n\n    if (version) {\n\n      if (!this._features[feature]) {\n        this._features[feature] = [];\n      }\n\n      if (version instanceof Array) {\n        Array.prototype.push.apply(this._features[feature], version);\n      } else {\n        this._features[feature].push(version);\n      }\n    }\n  },\n\n  // The real hasFeature is in living/dom-implementation.js, and returns true always.\n  // This one is used internally\n  _hasFeature: function(/* string */ feature, /* string */ version) {\n    feature = (feature) ? feature.toLowerCase() : '';\n    var versions = (this._features[feature]) ?\n                    this._features[feature]  :\n                    false;\n\n    if (!version && versions.length && versions.length > 0) {\n      return true;\n    } else if (typeof versions === 'string') {\n      return versions === version;\n    } else if (versions.indexOf && versions.length > 0) {\n      for (var i = 0; i < versions.length; i++) {\n        var found = versions[i] instanceof RegExp ?\n          versions[i].test(version) :\n          versions[i] === version;\n        if (found) { return true; }\n      }\n      return false;\n    } else {\n      return false;\n    }\n  }\n};\n\n\nvar attrCopy = function(src, dest, fn) {\n  if (src.attributes) {\n    var attrs = src.attributes, i, l = attrs.length, attr, copied;\n    for (i=0;i<l;i++) {\n      attr = attrs[i];\n      // skip over default attributes\n      if (!attr.specified) {\n        continue;\n      }\n      // TODO: consider duplicating this code and moving it into level2/core\n      if (attr.namespaceURI) {\n        dest.setAttributeNS(attr.namespaceURI,\n                                     attr.name,\n                                     attr.value);\n        var localName = attr.name.split(':').pop();\n        copied = dest.getAttributeNodeNS(attr.namespaceURI, localName);\n      } else {\n        dest.setAttribute(attr.name, attr.value);\n        copied = dest.getAttributeNode(attr.name);\n      }\n      if (typeof fn == \"function\") {\n        fn(attr, copied);\n      }\n\n    }\n  }\n  return dest;\n};\n\ncore.Node = function Node(ownerDocument) {\n  this._childNodes = [];\n  this._childNodesList = null;\n  this._ownerDocument = ownerDocument;\n  this._attributes = new AttributeList(ownerDocument, this);\n  this._childrenList = null;\n  this._version = 0;\n  this._parentNode = null;\n  this._memoizedQueries = {};\n  this._readonly = false;\n};\n\ncore.Node.ELEMENT_NODE                = ELEMENT_NODE;\ncore.Node.ATTRIBUTE_NODE              = ATTRIBUTE_NODE;\ncore.Node.TEXT_NODE                   = TEXT_NODE;\ncore.Node.CDATA_SECTION_NODE          = CDATA_SECTION_NODE;\ncore.Node.ENTITY_REFERENCE_NODE       = ENTITY_REFERENCE_NODE;\ncore.Node.ENTITY_NODE                 = ENTITY_NODE;\ncore.Node.PROCESSING_INSTRUCTION_NODE = PROCESSING_INSTRUCTION_NODE;\ncore.Node.COMMENT_NODE                = COMMENT_NODE;\ncore.Node.DOCUMENT_NODE               = DOCUMENT_NODE;\ncore.Node.DOCUMENT_TYPE_NODE          = DOCUMENT_TYPE_NODE;\ncore.Node.DOCUMENT_FRAGMENT_NODE      = DOCUMENT_FRAGMENT_NODE;\ncore.Node.NOTATION_NODE               = NOTATION_NODE;\n\ncore.Node.prototype = {\n  ELEMENT_NODE                : ELEMENT_NODE,\n  ATTRIBUTE_NODE              : ATTRIBUTE_NODE,\n  TEXT_NODE                   : TEXT_NODE,\n  CDATA_SECTION_NODE          : CDATA_SECTION_NODE,\n  ENTITY_REFERENCE_NODE       : ENTITY_REFERENCE_NODE,\n  ENTITY_NODE                 : ENTITY_NODE,\n  PROCESSING_INSTRUCTION_NODE : PROCESSING_INSTRUCTION_NODE,\n  COMMENT_NODE                : COMMENT_NODE,\n  DOCUMENT_NODE               : DOCUMENT_NODE,\n  DOCUMENT_TYPE_NODE          : DOCUMENT_TYPE_NODE,\n  DOCUMENT_FRAGMENT_NODE      : DOCUMENT_FRAGMENT_NODE,\n  NOTATION_NODE               : NOTATION_NODE,\n\n  get children() {\n    if (!this._childrenList) {\n      var self = this;\n      this._childrenList = new core.NodeList(this, function() {\n        return self._childNodes.filter(function(node) {\n          return node.tagName;\n        });\n      });\n    }\n    this._childrenList._update();\n    return this._childrenList;\n  },\n  get nodeValue() {\n    if (this.nodeType === core.Node.TEXT_NODE ||\n        this.nodeType === core.Node.COMMENT_NODE ||\n        this.nodeType === core.Node.PROCESSING_INSTRUCTION_NODE) {\n      return this._data;\n    }\n\n    return null;\n  },\n  set nodeValue(value) {\n    if (this.nodeType === core.Node.TEXT_NODE ||\n        this.nodeType === core.Node.COMMENT_NODE ||\n        this.nodeType === core.Node.PROCESSING_INSTRUCTION_NODE) {\n      this.replaceData(0, this.length, value);\n    }\n  },\n  get parentNode() { return this._parentNode;},\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case ELEMENT_NODE:\n        return this.tagName;\n      case TEXT_NODE:\n        return \"#text\";\n      case PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case COMMENT_NODE:\n        return \"#comment\";\n      case DOCUMENT_NODE:\n        return \"#document\";\n      case DOCUMENT_TYPE_NODE:\n        return this.name;\n      case DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n      case ATTRIBUTE_NODE:\n        // TODO: remove this; attributes should not be nodes and should not have a nodeName property\n        // Removing it breaks some legit-seeming xpath tests :-/\n        return this.name;\n    }\n  },\n  set nodeName(unused) { throw new core.DOMException();},\n  get firstChild() {\n    return this._childNodes.length > 0 ? this._childNodes[0] : null;\n  },\n  get ownerDocument() { return this._ownerDocument;},\n  get readonly() { return this._readonly;},\n\n  get lastChild() {\n    var len = this._childNodes.length;\n    return len > 0 ? this._childNodes[len -1] : null;\n  },\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      var self = this;\n      this._childNodesList = new core.NodeList(this, function() {\n        return self._childNodes.slice();\n      });\n    }\n    this._childNodesList._update();\n    return this._childNodesList;\n  },\n  set childNodes(unused) { throw new core.DOMException();},\n\n  _indexOf: function(/*Node*/ child) {\n    return this._childNodes.indexOf(child);\n  },\n\n  get nextSibling() {\n    // find this node's index in the parentNode, add one and call it a day\n    if (!this._parentNode || !this._parentNode._indexOf) {\n      return null;\n    }\n\n    var index = this._parentNode._indexOf(this);\n\n    if (index == -1 || index+1 >= this._parentNode._childNodes.length) {\n      return null;\n    }\n\n    return this._parentNode._childNodes[index+1] || null;\n  },\n  set nextSibling(unused) { throw new core.DOMException();},\n\n  get previousSibling() {\n    if (!this._parentNode || !this._parentNode._indexOf) {\n      return null;\n    }\n\n    var index = this._parentNode._indexOf(this);\n\n    if (index == -1 || index-1 < 0) {\n      return null;\n    }\n\n    return this._parentNode._childNodes[index-1] || null;\n  },\n  set previousSibling(unused) { throw new core.DOMException();},\n\n  /* returns Node */\n  insertBefore :  function(/* Node */ newChild, /* Node*/ refChild) {\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR, 'Attempting to modify a read-only node');\n    }\n\n    // Adopt unowned children, for weird nodes like DocumentType\n    if (!newChild._ownerDocument) newChild._ownerDocument = this._ownerDocument;\n\n    // TODO - if (!newChild) then?\n    if (!(this instanceof core.Document) && newChild._ownerDocument !== this._ownerDocument) {\n      throw new core.DOMException(WRONG_DOCUMENT_ERR);\n    }\n\n    if (newChild.nodeType && newChild.nodeType === ATTRIBUTE_NODE) {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    // search for parents matching the newChild\n    var current = this;\n    do {\n      if (current === newChild) {\n        throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n      }\n    } while((current = current._parentNode));\n\n    // fragments are merged into the element (except parser-created fragments in <template>)\n    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE && !newChild._templateContent) {\n      var tmpNode, i = newChild._childNodes.length;\n      while (i-- > 0) {\n        tmpNode = newChild.removeChild(newChild.firstChild);\n        this.insertBefore(tmpNode, refChild);\n      }\n    } else if (newChild === refChild) {\n      return newChild;\n    } else {\n      // if the newChild is already in the tree elsewhere, remove it first\n      if (newChild._parentNode) {\n        newChild._parentNode.removeChild(newChild);\n      }\n\n      if (refChild == null) {\n        this._childNodes.push(newChild);\n      } else {\n        var refChildIndex = this._indexOf(refChild);\n        if (refChildIndex == -1) {\n          throw new core.DOMException(NOT_FOUND_ERR);\n        }\n        this._childNodes.splice(refChildIndex, 0, newChild);\n      }\n\n      newChild._parentNode = this;\n      if (this._attached && newChild._attach) {\n        newChild._attach();\n      }\n\n      this._modified();\n      this._descendantAdded(this, newChild);\n    }\n\n    return newChild;\n  }, // raises(DOMException);\n\n  _modified: function() {\n    this._version++;\n    if (this._ownerDocument) {\n      this._ownerDocument._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    this._clearMemoizedQueries()\n  },\n\n  _clearMemoizedQueries: function() {\n    this._memoizedQueries = {};\n    if (this._parentNode && this._parentNode !== this) {\n      this._parentNode._clearMemoizedQueries();\n    }\n  },\n\n  _descendantRemoved: function(parent, child) {\n    if (this._parentNode && this._parentNode !== this) {\n      this._parentNode._descendantRemoved(parent, child);\n    }\n  },\n\n  _descendantAdded: function(parent, child) {\n    if (this._parentNode && this._parentNode !== this) {\n      this._parentNode._descendantAdded(parent, child);\n    }\n  },\n\n  _attrModified: function(name, value, oldValue) {\n    if (name == 'id' && this._attached) {\n      var doc = this._ownerDocument;\n      detachId(oldValue,this,doc);\n      attachId(value,this,doc);\n    }\n\n    // Check for inline event handlers.\n    // We can't set these like other attributes then look it up in\n    // dispatchEvent() because that would create 2 'traditional' event handlers\n    // in the case where there's an inline event handler attribute, plus one\n    // set using element.on* in a script.\n    //\n    // @see http://www.w3.org/TR/2011/WD-html5-20110405/webappapis.html#event-handler-content-attributes\n    if ((name.length > 2) && (name[0] == 'o') && (name[1] == 'n')) {\n        if (value) {\n          var self = this;\n          // Check whether we're the window. This can happen because inline\n          // handlers on the body are proxied to the window.\n          var w = (typeof self.run !== 'undefined') ? self : self._ownerDocument.parentWindow;\n          self[name] = function (event) {\n              // The handler code probably refers to functions declared in the\n              // window context, so we need to call run().\n\n              // Use awesome hacks to get the correct `this` context for the\n              // inline event handler. This would only be necessary if we're an\n              // element, but for the sake of simplicity we also do it on window.\n\n              // Also set event variable and support `return false`.\n              w.__tempContextForInlineEventHandler = self;\n              w.__tempEvent = event;\n              w.run(\"if ((function (event) {\" + value + \"}).call(\" +\n                \"window.__tempContextForInlineEventHandler, window.__tempEvent) === false) {\" +\n                \"window.__tempEvent.preventDefault()}\");\n              delete w.__tempContextForInlineEventHandler;\n              delete w.__tempEvent;\n          };\n        } else {\n          this[name] = null;\n        }\n    }\n  },\n\n  /* returns Node */\n  replaceChild : function(/* Node */ newChild, /* Node */ oldChild){\n    this.insertBefore(newChild, oldChild);\n    return this.removeChild(oldChild);\n  }, //raises(DOMException);\n\n  /* returns void */\n  _attach : function() {\n    this._attached = true;\n    if (this.id) {\n      attachId(this.id,this,this._ownerDocument);\n    }\n    for (var i = 0, len = this._childNodes.length; i < len; i++) {\n      if (this._childNodes[i]._attach) {\n        this._childNodes[i]._attach();\n      }\n    }\n  },\n  /* returns void */\n  _detach : function() {\n    var i, elms;\n    this._attached = false;\n    if (this.id) {\n      detachId(this.id,this,this._ownerDocument);\n    }\n    for (var i = 0, len = this._childNodes.length; i < len; i++) {\n      this._childNodes[i]._detach();\n    }\n  },\n\n  /* returns Node */\n  removeChild : function(/* Node */ oldChild){\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    // TODO - if (!oldChild) then?\n\n    // Use lastIndexOf so that removing all the children by\n    // going backwards through childNodes is fast\n    // (because of splice)\n    var oldChildIndex = this._childNodes.lastIndexOf(oldChild);\n    if (oldChildIndex == -1) {\n      throw new core.DOMException(NOT_FOUND_ERR);\n    }\n\n    this._childNodes.splice(oldChildIndex, 1);\n    oldChild._parentNode = null;\n    this._modified();\n    oldChild._detach();\n    this._descendantRemoved(this, oldChild);\n    return oldChild;\n  }, // raises(DOMException);\n\n  /* returns Node */\n  appendChild : function(/* Node */ newChild) {\n    return this.insertBefore(newChild, null);\n  }, // raises(DOMException);\n\n  /* returns boolean */\n  hasChildNodes : function() {\n    return this._childNodes.length > 0;\n  },\n\n  /* returns Node */\n  cloneNode : function(/* bool */ deep, fn) {\n\n    var object = null;\n    switch (this.nodeType) {\n\n      case this.ELEMENT_NODE:\n        object = attrCopy(this,this._ownerDocument.createElementNS(this.namespaceURI, this.nodeName), fn);\n        // Using this.nodeName isn't always exact because of uppercasing-related stuff\n        object._prefix = this._prefix;\n        object._localName = this._localName;\n      break;\n\n      case this.TEXT_NODE:\n        object = attrCopy(this,this._ownerDocument.createTextNode(this.tagName));\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.ATTRIBUTE_NODE:\n        object = this._ownerDocument.createAttribute(this.name);\n      break;\n      break;\n      case this.PROCESSING_INSTRUCTION_NODE:\n        var pi = this._ownerDocument.createProcessingInstruction(this._target,\n                                                                this._data);\n        object = attrCopy(this, pi);\n      break;\n      case this.COMMENT_NODE:\n        object = this._ownerDocument.createComment(this.tagName);\n        object.nodeValue = this.nodeValue;\n      break;\n      case this.DOCUMENT_NODE:\n        object = attrCopy(this, new this.constructor({ parsingMode: this._parsingMode }));\n        // TODO: clone the doctype?\n      break;\n      case this.DOCUMENT_TYPE_NODE:\n        object = new core.DocumentType(this._ownerDocument, this._name, this._publicId, this._systemId);\n      break;\n      case this.DOCUMENT_FRAGMENT_NODE:\n        object = this._ownerDocument.createDocumentFragment();\n      break;\n      default:\n        throw new core.DOMException(NOT_FOUND_ERR);\n      break;\n    }\n\n    if (typeof fn === \"function\") {\n      fn(this, object);\n    }\n\n    if (deep || this.nodeType === ATTRIBUTE_NODE) {\n      var clone = null;\n      for (var i=0,len=this._childNodes.length;i<len;i++)\n      {\n        clone = this._childNodes[i].cloneNode(true);\n        if (clone.nodeType === ATTRIBUTE_NODE) {\n          object.setAttributeNode(clone);\n        } else {\n          var readonly = object._readonly;\n          object._readonly = false;\n          object.appendChild(clone);\n          object._readonly = readonly;\n        }\n      }\n    }\n\n    return object;\n  },\n\n  /* returns void */\n  normalize: function() {\n    var prevChild, child, attr,i;\n\n    if (this._attributes && this._attributes.length) {\n      for (i=0;i<this._attributes.length;i++)\n      {\n        if (this._attributes[i]) {\n          attr = this._attributes[i].normalize();\n        }\n      }\n    }\n\n    for (i=0;i<this._childNodes.length;i++)\n    {\n      child = this._childNodes[i];\n\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      // Level2/core clean off empty nodes\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        i--;\n        continue;\n      }\n\n      if (i>0) {\n        prevChild = this._childNodes[i-1];\n\n        if (child.nodeType === TEXT_NODE &&\n            prevChild.nodeType === TEXT_NODE)\n        {\n\n          // remove the child and decrement i\n          prevChild.appendData(child.nodeValue);\n\n          this.removeChild(child);\n          i--;\n        }\n      }\n    }\n  },\n  toString: function() {\n    var id = '';\n    if (this.id) {\n        id = '#' + this.id;\n    }\n    if (this.className) {\n        var classes = this.className.split(/\\s+/);\n\tfor (var i = 0, len = classes.length; i < len; i++) {\n\t    id += '.' + classes[i];\n\t}\n    }\n    return '[ ' + this.tagName + id + ' ]';\n  },\n  raise: function(type, message, data) {\n    var text = type + \": \" + message;\n\n    if (data) {\n      if (data.exception) {\n        text = data.exception.stack;\n      } else {\n        text += ' - More:\\n' + data;\n      }\n    }\n\n    if (type === \"error\") {\n      if (!this.errors) {\n        this.errors = [];\n      }\n      // TODO: consider using actual `Error` objects or `DOMException`s even..\n      var err = {\n        type    : type,\n        message : message || \"No message\",\n        data    : data || null\n      };\n\n      this.errors.push(err);\n\n      if (this._ownerDocument        &&\n          this._ownerDocument.raise &&\n          this !== this._ownerDocument)\n      {\n        this._ownerDocument.raise(type, message, data);\n      }\n    }\n  }\n};\n\n\ncore.NamedNodeMap = function NamedNodeMap(document) {\n  this._nodes = Object.create(null);\n  this._nsStore = {};\n  this.length = 0;\n  this._ownerDocument = document;\n  this._readonly = false;\n};\ncore.NamedNodeMap.prototype = {\n  get readonly() { return this._readonly;},\n  get ownerDocument() { this._ownerDocument;},\n\n  exists : function(name) {\n    return (this._nodes[name] || this._nodes[name] === null) ? true : false;\n  },\n\n  /* returns Node */\n  getNamedItem: function(/* string */ name) {\n    return this._nodes[name] || null;\n  },\n\n  /* returns Node */\n  setNamedItem: function(/* Node */ arg) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    // arg is from a different document\n    if (arg && arg._ownerDocument !== this._ownerDocument) {\n      throw new core.DOMException(WRONG_DOCUMENT_ERR);\n    }\n\n    // if this argument is already in use..\n    if (arg && arg._ownerElement) {\n      throw new core.DOMException(INUSE_ATTRIBUTE_ERR);\n    }\n\n    var name = arg.name || arg.tagName;\n    var ret = this._nodes[name];\n    if (!ret) {\n      this.length++;\n      ret = null;\n    }\n    this._nodes[name] = arg;\n\n    // Avoid overwriting prototype methods etc.:\n    if (this.hasOwnProperty(name) || !(name in this)) {\n      this[name] = arg;\n    }\n    return ret;\n  }, // raises: function(DOMException) {},\n\n  /* returns Node */\n  removeNamedItem: function(/* string */ name) {\n\n    // readonly\n    if (this._readonly === true) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (!this._nodes[name]) {\n      throw new core.DOMException(NOT_FOUND_ERR);\n    }\n\n    var prev = this._nodes[name] || null;\n    delete this._nodes[name];\n    delete this[name];\n\n    this.length--;\n    return prev;\n  }, // raises: function(DOMException) {},\n\n  /* returns Node */\n  item: function(/* int */ index) {\n    var current = 0;\n    for (var member in this._nodes) {\n      if (current === index && this._nodes[member]) {\n        return this._nodes[member];\n      }\n      current++;\n    }\n    return null;\n  }\n};\n\n//\n// For historical reasons, AttributeList objects must allow accessing\n// attributes as if the object were an associative array. For\n// instance, if `attributes` is an AttributeList object then\n// `attributes.x` should evaluate to the attribute named `x` (which is\n// not in any namespace). The AttributeList class uses the dollar\n// symbol ($) to reduce the possibility of a clash between its field\n// names and possible attribute names. For instance, if the method\n// currently named `$set` were instead named `set` then it would not\n// be possible to access an attribute named `set` through\n// `attributes.set`. The dollar symbol is not valid in attribute names\n// so `$set` cannot clash.\n//\n// Some fields do not get the $ because:\n//\n// * They are part of the API (e.g. `setNamedItem`, `length`), so they\n//   must be visible under a specific name.\n//\n// * Jsdom's code which traverses the DOM tree expects regularly named\n//   fields (e.g. `_parentNode`).\n//\nfunction AttributeList(document, parentNode) {\n  this._ownerDocument = document;\n  this._parentNode = parentNode;\n  this._readonly = false;\n  this._$ns_to_attrs = Object.create(null);\n  this._$name_to_attrs = Object.create(null);\n  this.length = 0;\n}\n\nAttributeList.prototype = {\n  _$reserved: [], // Initialized later\n\n\n  //\n  // Code internal to jsdom and which manipulates an AttributeList\n  // object should use the following methods rather than the methods\n  // that provide the NamedNodeMap interface.\n  //\n\n  // This method *ignores* namespaces. This is *not* the same thing as\n  // requesting an attribute with a null namespace.\n  $getNoNS: function (name) {\n    var attrs = this._$name_to_attrs[name];\n    if (!attrs) {\n      return null;\n    }\n\n    return attrs[0] || null;\n  },\n\n  $getNode: function (namespace, localName) {\n    var attrs = this._$ns_to_attrs[namespace];\n    if (!attrs) {\n      return null;\n    }\n\n    var ret = attrs[localName];\n    if (!ret) {\n      return null;\n    }\n\n    return ret;\n  },\n\n  // This method *ignores* namespaces. This is *not* the same thing as\n  // requesting an attribute with a null namespace.\n  $setNoNS: function (name, value, dontValidate) {\n    var attr = this.$getNoNS(name);\n    if (!attr) {\n      this.$set(name, value, undefined, undefined, undefined, dontValidate);\n      return;\n    }\n\n    var prev_val = attr.value;\n    attr.value = value;\n\n    this._parentNode._attrModified(attr.name, attr.value, prev_val);\n    this._parentNode._modified();\n  },\n\n  $set: function (localName, value, name, prefix, namespace, dontValidate) {\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (name === undefined) {\n      name = localName;\n    }\n\n    if (prefix === undefined) {\n      prefix = null;\n    }\n\n    if (namespace === undefined) {\n      namespace = null;\n    }\n\n    var prev_attr = this.$getNode(namespace, localName);\n    var attr;\n\n    var prev_val = null;\n    if (prev_attr) {\n      prev_val = prev_attr.value;\n      prev_attr._prefix = prefix;\n      prev_attr.value = value;\n      attr = prev_attr;\n\n      this._parentNode._attrModified(attr.name, attr.value, prev_val);\n      this._parentNode._modified();\n    }\n    else {\n      var method = dontValidate ? '_createAttributeNoNameValidation' : 'createAttribute';\n      attr = this._ownerDocument[method](name);\n      attr._ownerElement = this._parentNode;\n      attr.value = value;\n      attr._namespaceURI = namespace;\n      attr._prefix = prefix;\n      attr._localName = localName;\n      attr._parentNode = this._parentNode;\n      this.$setNode(attr);\n      // $setNode calls the parent node methods.\n    }\n  },\n\n  $setNode: function (attr) {\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    if (attr.nodeType !== ATTRIBUTE_NODE) {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    if (attr._ownerDocument !== this._ownerDocument) {\n      throw new core.DOMException(WRONG_DOCUMENT_ERR);\n    }\n\n    if (attr._parentNode && attr._parentNode !== this._parentNode) {\n      throw new core.DOMException(INUSE_ATTRIBUTE_ERR);\n    }\n\n    var localName = attr._localName;\n    var name = attr.name;\n    var prefix = attr._prefix;\n    var namespace = attr._namespaceURI;\n\n    if (name === undefined) {\n      name = localName;\n    }\n\n    if (prefix === undefined) {\n      prefix = null;\n    }\n\n    if (namespace === undefined) {\n      namespace = null;\n    }\n\n    var prev_attr = this.$getNode(namespace, localName);\n\n    var prev_val = null;\n    if (prev_attr) {\n      prev_val = prev_attr.value;\n      // Remove the old attribute\n      this._$onlyRemoveNode(prev_attr);\n    }\n\n    attr._parentNode = this._parentNode;\n    attr._ownerElement = this._parentNode;\n\n    var attrs = this._$ns_to_attrs[namespace];\n    if (!attrs) {\n      attrs = this._$ns_to_attrs[namespace] = Object.create(null);\n    }\n    attrs[localName] = attr;\n\n    attrs = this._$name_to_attrs[name];\n    if (!attrs) {\n      attrs = this._$name_to_attrs[name] = [attr];\n    }\n    else {\n      attrs.push(attr);\n    }\n\n    // Only attributes in the null namespace can be set this way.\n    if (namespace === null) {\n      // Make the node a field on this object but ONLY if it does not\n      // clash with the reserved names.\n      if (this._$reserved.indexOf(name) === -1) {\n        this[name] = attr;\n      }\n    }\n\n    this[this.length] = attr;\n    this.length++;\n\n    this._parentNode._attrModified(attr.name, attr.value, prev_val);\n    this._parentNode._modified();\n\n    return prev_attr;\n  },\n\n  // This method *ignores* namespaces. This is *not* the same thing as\n  // requesting an attribute with a null namespace.\n  $removeNoNS: function (name) {\n    var attr = this.$getNoNS(name);\n    return attr ? this.$removeNode(attr) : null;\n  },\n\n  $remove: function (namespace, localName) {\n    var attr = this.$getNode(namespace, localName);\n    return attr ? this.$removeNode(attr) : null;\n  },\n\n  /* Only removes the node, and does not add a default value. */\n  _$onlyRemoveNode: function (attr) {\n    var namespace = attr._namespaceURI;\n    var localName = attr._localName;\n\n    var attrs = this._$ns_to_attrs[namespace];\n    if (!attrs) {\n      return null;\n    }\n\n    var found_attr = attrs[localName];\n    if (found_attr !== attr) {\n      return null;\n    }\n\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    attr._ownerElement = null;\n    attr._parentNode = null;\n    delete attrs[localName];\n\n    attrs = this._$name_to_attrs[attr.name];\n    attrs.splice(attrs.indexOf(attr), 1);\n\n    var ix = Array.prototype.indexOf.call(this, attr);\n    // Splice also modifies length.\n    Array.prototype.splice.call(this, ix, 1);\n\n    if (this[attr.name] === attr) {\n      delete this[attr.name];\n    }\n\n    this._parentNode._attrModified(attr.name);\n    this._parentNode._modified();\n\n    return attr;\n  },\n\n  $removeNode: function (attr) {\n    if (!this._$onlyRemoveNode(attr)) {\n      return null;\n    }\n    return attr;\n  },\n\n  // Although http://dom.spec.whatwg.org/#concept-element-attribute\n  // does not specify that the attributes field on an Element should\n  // support NamedNodeMap, in practice browsers still support this\n  // interface so we should support it for compatibility.\n\n  getNamedItem: function (name) {\n    return this.getNamedItemNS(null, name);\n  },\n  removeNamedItem: function (name) {\n    return this.removeNamedItemNS(null, name);\n  },\n  item: function (i) {\n      return this[i];\n  },\n  getNamedItemNS: function (namespaceURI, localName) {\n    if (namespaceURI === \"\") {\n      namespaceURI = null;\n    }\n\n    return this.$getNode(namespaceURI, localName);\n  },\n  removeNamedItemNS: function (namespaceURI, localName) {\n    var ret = this.$remove(namespaceURI, localName);\n\n    if (ret === null) {\n      throw new core.DOMException(NOT_FOUND_ERR);\n    }\n\n    return ret;\n  }\n};\n\n// Alias these methods.\nAttributeList.prototype.setNamedItem = AttributeList.prototype.$setNode;\nAttributeList.prototype.setNamedItemNS = AttributeList.prototype.$setNode;\n\n(function () {\n  // Construct the list of reserved attribute names from a temporarily\n  // created AttributeList and from the chain of prototypes. We need\n  // this because JavaScript code running an a browser expects to be\n  // able to do el.attributes.x to get the value of the attribute \"x\"\n  // on an element. Unfortunately, JavaScript *currently* does not\n  // allow us to elegantly provide such functionality without risking\n  // a clash with the fields and methods set on the AttributeList\n  // object. Hence we need a list of reserved field names.\n\n  var reserved = Object.keys(new AttributeList());\n  var prototype = AttributeList.prototype;\n  while (prototype) {\n    reserved = reserved.concat(Object.getOwnPropertyNames(prototype));\n    prototype = Object.getPrototypeOf(prototype);\n  }\n  AttributeList.prototype._$reserved = reserved;\n})();\n\ncore.AttributeList = AttributeList;\n\ncore.Element = function Element(document, localName) {\n  core.Node.call(this, document);\n  this._namespaceURI = null;\n  this._prefix = null;\n  this._localName = localName;\n};\n\ninheritFrom(core.Node, core.Element, {\n  get namespaceURI() {\n    return this._namespaceURI;\n  },\n  get prefix() {\n    return this._prefix;\n  },\n  get localName() {\n    return this._localName;\n  },\n  get tagName() {\n    var qualifiedName = this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n    if (this.namespaceURI === \"http://www.w3.org/1999/xhtml\" && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = qualifiedName.toUpperCase();\n    }\n    return qualifiedName;\n  },\n\n  get id() {\n    var idAttr = this.getAttribute(\"id\");\n    if (idAttr === null) {\n      return \"\";\n    }\n    return idAttr;\n  },\n\n  nodeType : ELEMENT_NODE,\n  get attributes() {\n    return this._attributes;\n  },\n\n  get sourceIndex() {\n    /*\n    * According to QuirksMode:\n    * Get the sourceIndex of element x. This is also the index number for\n    * the element in the document.getElementsByTagName('*') array.\n    * http://www.quirksmode.org/dom/w3c_core.html#t77\n    */\n    var items = this.ownerDocument.getElementsByTagName('*'),\n        len = items.length;\n\n    for (var i = 0; i < len; i++) {\n      if (items[i] === this) {\n        return i;\n      }\n    }\n  },\n\n  get outerHTML() {\n    return domToHtml(this, true);\n  },\n\n  get innerHTML() {\n    var tagName = this.tagName;\n    if (tagName === 'SCRIPT' || tagName === 'STYLE') {\n      var type = this.getAttribute('type');\n      if (!type || /^text\\//i.test(type) || /\\/javascript$/i.test(type)) {\n        return domToHtml(this._childNodes, true, true);\n      }\n    }\n\n    // In case of <template> we should pass it's content fragment as a serialization root if we have one\n    if(tagName === 'TEMPLATE' &&\n       this._namespaceURI === 'http://www.w3.org/1999/xhtml' &&\n       this._childNodes[0] && this._childNodes[0]._templateContent) {\n      return domToHtml(this._childNodes[0]._childNodes, true);\n    }\n\n    return domToHtml(this._childNodes, true);\n  },\n\n  set innerHTML(html) {\n    setInnerHTML(this.ownerDocument, this, html);\n  },\n\n  scrollTop: 0,\n  scrollLeft: 0,\n\n  hasAttributes: function () {\n    return this._attributes.length > 0;\n  },\n\n  /* returns Attr */\n  setAttributeNode: function(/* Attr */ newAttr) {\n    var prevNode = this._attributes.$getNode(null, newAttr.name);\n    if (prevNode) {\n      prevNode._ownerElement = null;\n    }\n\n    newAttr._ownerElement = this;\n    this._attributes.$setNode(newAttr);\n\n    return (prevNode && prevNode.specified) ? prevNode : null;\n  }, //  raises: function(DOMException) {},\n\n  /* returns Attr */\n  removeAttributeNode: function(/* Attr */ oldAttr) {\n    var ret = this._attributes.$removeNode(oldAttr);\n\n    if (ret !== null) {\n      return ret;\n    }\n\n    throw new core.DOMException(NOT_FOUND_ERR);\n  }, //raises: function(DOMException) {},\n\n  /* returns NodeList */\n  getElementsByTagName: memoizeQuery(function(/* string */ name) {\n    name = name.toLowerCase();\n\n    function filterByTagName(child) {\n      if (child.nodeName && child.nodeType === ELEMENT_NODE) {\n        return name === \"*\" || (child.nodeName.toLowerCase() === name);\n      }\n\n      return false;\n    }\n    return new core.NodeList(this._ownerDocument || this, core.mapper(this, filterByTagName, true));\n  }),\n\n  getElementsByClassName: function (className) {\n\n    function filterByClassName(child) {\n      if (!child) {\n        return false;\n      }\n\n      var classString = child.className;\n      if (classString) {\n        var s = classString.split(\" \");\n        for (var i = 0; i < s.length; i++) {\n          if (s[i] === className) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    return new core.NodeList(this.ownerDocument || this, core.mapper(this, filterByClassName));\n  }\n});\n\ncore.DocumentFragment = function DocumentFragment(document) {\n  core.Node.call(this, document);\n};\ninheritFrom(core.Node, core.DocumentFragment, {\n  nodeType : DOCUMENT_FRAGMENT_NODE\n});\n\ncore.Document = function Document(options) {\n  if (!options || !options.parsingMode || (options.parsingMode !== \"html\" && options.parsingMode !== \"xml\")) {\n    throw new Error(\"options must exist and contain a parsingMode of html or xml\");\n  }\n\n  core.Node.call(this, \"#document\");\n  this._parsingMode = options.parsingMode;\n  this._implementation = new core.DOMImplementation(this);\n  this._documentElement = null;\n  this._ids = Object.create(null);\n  this._attached = true;\n  this._ownerDocument = this;\n  this._readonly = false;\n\n  this._contentType = options.contentType;\n  if (this._contentType === undefined) {\n    this._contentType = this._parsingMode === \"xml\" ? \"application/xml\" : \"text/html\";\n  }\n\n  this._URL = options.url;\n  if (this._URL === undefined) {\n    this._URL = \"about:blank\";\n  }\n  this._location = new Location(this._URL, this);\n};\n\n\nvar tagRegEx = /[^\\w:\\d_\\.-]+/i;\nvar entRegEx = /[^\\w\\d_\\-&;]+/;\nvar invalidAttrRegEx = /[\\s\"'>/=\\u0000-\\u001A]/;\n\ninheritFrom(core.Node, core.Document, {\n  nodeType : DOCUMENT_NODE,\n  _elementBuilders : { },\n  _defaultElementBuilder: function(document, tagName) {\n    return new core.Element(document, tagName);\n  },\n  get contentType() { return this._contentType;},\n  get compatMode() { return (this._parsingMode === \"xml\" || this.doctype) ? \"CSS1Compat\" : \"BackCompat\"; },\n  get characterSet() { return \"UTF-8\"; },\n  get inputEncoding() { return \"UTF-8\"; },\n  get doctype() {\n    for (var i = 0; i < this._childNodes.length; ++i) {\n      if (this._childNodes[i].nodeType === DOCUMENT_TYPE_NODE) {\n        return this._childNodes[i];\n      }\n    }\n    return null;\n  },\n  get URL() {\n    return this._URL;\n  },\n  get documentURI() {\n    return this._URL;\n  },\n  get location() {\n    return this._location;\n  },\n  get documentElement() {\n    if (this._documentElement) {\n      return this._documentElement;\n    } else {\n      for (var i = 0; i < this._childNodes.length; ++i) {\n        if (this._childNodes[i].nodeType === ELEMENT_NODE) {\n          this._documentElement = this._childNodes[i];\n          return this._documentElement;\n        }\n      }\n      return null;\n    }\n  },\n\n  get implementation() { return this._implementation;},\n  set implementation(implementation) { this._implementation = implementation;},\n  get ownerDocument() { return null;},\n  get readonly() { return this._readonly;},\n\n  set parentWindow(window) {\n    // Contextify does not support getters and setters, so we have to set them\n    // on the original object instead.\n    window._frame = function (name, frame) {\n      if (typeof frame === 'undefined') {\n        delete window[name];\n      } else {\n        defineGetter(window, name, function () { return frame.contentWindow; });\n      }\n    };\n    this._parentWindow = window.getGlobal();\n  },\n\n  get defaultView() {\n    return this.parentWindow;\n  },\n\n  toString: function () {\n    return '[object HTMLDocument]';\n  },\n\n  _createElementNoTagNameValidation: function (tagName) {\n    var element = (this._elementBuilders[tagName.toLowerCase()] || this._defaultElementBuilder)(this, tagName);\n    element._namespaceURI = \"http://www.w3.org/1999/xhtml\";\n    return element;\n  },\n\n  createElement: function (localName) {\n    localName = String(localName);\n    validateName(localName, core);\n    if (this._parsingMode === \"html\") {\n      localName = localName.toLowerCase();\n    }\n\n    return this._createElementNoTagNameValidation(localName);\n  },\n\n  /* returns DocumentFragment */\n  createDocumentFragment: function() {\n    return new core.DocumentFragment(this);\n  },\n\n  /* returns Attr */\n  createAttribute: function (localName) {\n    localName = String(localName);\n    validateName(localName, core);\n\n    return this._createAttributeNoNameValidation(localName);\n  }, // raises: function(DOMException) {},\n\n  _createAttributeNoNameValidation: function (localName) {\n    return new core.Attr(this, localName, \"\");\n  },\n\n  appendChild : function(/* Node */ arg) {\n    if (this.documentElement && arg.nodeType == ELEMENT_NODE) {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n    return core.Node.prototype.appendChild.call(this, arg);\n  },\n\n  removeChild : function(/* Node */ arg) {\n    var ret = core.Node.prototype.removeChild.call(this, arg);\n    if (arg == this._documentElement) {\n      this._documentElement = null;// force a recalculation\n    }\n    return ret;\n  },\n\n  /* returns NodeList */\n  getElementsByTagName: memoizeQuery(function(/* string */ name) {\n    function filterByTagName(child) {\n      if (child.nodeName && child.nodeType === ELEMENT_NODE)\n      {\n        if (name === \"*\") {\n          return true;\n\n        // case insensitivity for html\n        } else if (child._ownerDocument && child._ownerDocument._doctype &&\n                   //child._ownerDocument._doctype.name === \"html\" &&\n                   child.nodeName.toLowerCase() === name.toLowerCase())\n        {\n          return true;\n        } else if (child.nodeName.toLowerCase() === name.toLowerCase()) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return new core.NodeList(this.documentElement || this, core.mapper(this, filterByTagName, true));\n  }),\n\n  getElementsByClassName: function (className) {\n\n    function filterByClassName(child) {\n      if (!child) {\n        return false;\n      }\n\n      var classString = child.className;\n      if (classString) {\n        var s = classString.split(\" \");\n        for (var i = 0; i < s.length; i++) {\n          if (s[i] === className) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    return new core.NodeList(this.ownerDocument || this, core.mapper(this, filterByClassName));\n  },\n\n  write: function (text) {\n    if (this._writeAfterElement) {\n      // If called from an script element directly (during the first tick),\n      // the new elements are inserted right after that element.\n      var tempDiv = this.createElement('div');\n      setInnerHTML(this, tempDiv, text);\n\n      var child = tempDiv.firstChild;\n      var previous = this._writeAfterElement;\n      var parent = this._writeAfterElement.parentNode;\n\n      while (child) {\n        var node = child;\n        child = child.nextSibling;\n        parent.insertBefore(node, previous.nextSibling);\n        previous = node;\n      }\n    } else if (this.readyState === \"loading\") {\n      // During page loading, document.write appends to the current element\n      // Find the last child that has been added to the document.\n      var node = this;\n      while (node.lastChild && node.lastChild.nodeType === this.ELEMENT_NODE) {\n        node = node.lastChild;\n      }\n      setInnerHTML(this, node, text || \"<html><head></head><body></body></html>\");\n    } else if (text) {\n      setInnerHTML(this, this, text);\n    }\n  }\n});\n\ncore.Attr = function Attr(document, name, value) {\n  core.Node.call(this, document);\n  this._valueForAttrModified = value;\n  this._name = name;\n  this._ownerElement = null;\n  this._namespaceURI = null;\n  this._localName = name;\n  this._prefix = null;\n};\ninheritFrom(core.Node, core.Attr, {\n  nodeType : ATTRIBUTE_NODE,\n  get namespaceURI() {\n    return this._namespaceURI;\n  },\n  get prefix() {\n    return this._prefix;\n  },\n  get localName() {\n    return this._localName;\n  },\n  get name() {\n    return this._name;\n  },\n  get ownerElement() {\n    return this._ownerElement;\n  },\n  get nodeValue() {\n    var val = '';\n    for (var i=0,len=this._childNodes.length;i<len;i++) {\n      var child = this._childNodes[i];\n      val += child.nodeValue;\n    }\n    return val;\n  },\n  set nodeValue(value) {\n    // readonly\n    if (this._readonly) {\n      throw new core.DOMException(NO_MODIFICATION_ALLOWED_ERR);\n    }\n\n    this._childNodes.length = 1;\n    this._childNodes[0] = this._ownerDocument.createTextNode(value);\n    this._modified();\n    var prev = this._valueForAttrModified;\n    this._nodeValue = value;\n    if (this._ownerElement) {\n      this._ownerElement._attrModified(this._name, value, prev);\n    }\n  },\n  get specified() {\n    return true;\n  },\n  get value() {\n    return this.nodeValue;\n  },\n  set value(value) {\n    this.nodeValue = value;\n  },\n  get parentNode() { return null;},\n\n  insertBefore : function(/* Node */ newChild, /* Node*/ refChild){\n    if (newChild.nodeType === CDATA_SECTION_NODE ||\n        newChild.nodeType === ELEMENT_NODE)\n    {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    return core.Node.prototype.insertBefore.call(this, newChild, refChild);\n  },\n\n  appendChild : function(/* Node */ arg) {\n\n    if (arg.nodeType === CDATA_SECTION_NODE ||\n        arg.nodeType === ELEMENT_NODE)\n    {\n      throw new core.DOMException(HIERARCHY_REQUEST_ERR);\n    }\n\n    return core.Node.prototype.appendChild.call(this, arg);\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/domtohtml.js":"\"use strict\";\n\nvar parse5 = require('parse5');\nvar serializer = new parse5.TreeSerializer(require('./documentAdapter'));\n\nexports.domToHtml = function(dom) {\n  if (dom._toArray) {\n    // node list\n    dom = dom._toArray();\n  }\n  if (typeof dom.length !== \"undefined\") {\n    var ret = \"\";\n    for (var i = 0, len = dom.length; i < len; i++) {\n      ret += dom[i].nodeType === dom.DOCUMENT_NODE ?\n        serializer.serialize(dom[i]) :\n        serializer.serialize({ childNodes: [dom[i]] });\n    }\n    return ret;\n  } else {\n    return dom.nodeType === dom.DOCUMENT_NODE ?\n      serializer.serialize(dom) :\n      serializer.serialize({ childNodes: [dom] });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/documentAdapter.js":"//Tree traversing\nexports.getFirstChild = function (node) {\n  return node.childNodes[0];\n};\n\nexports.getChildNodes = function (node) {\n  return node.childNodes;\n};\n\nexports.getParentNode = function (node) {\n  return node.parentNode;\n};\n\nexports.getAttrList = function (node) {\n  return node.attributes;\n};\n\n//Node data\nexports.getTagName = function (element) {\n  return element.tagName.toLowerCase();\n};\n\nexports.getNamespaceURI = function (element) {\n  return element.namespaceURI || 'http://www.w3.org/1999/xhtml';\n};\n\nexports.getTextNodeContent = function (textNode) {\n  return textNode.nodeValue;\n};\n\nexports.getCommentNodeContent = function (commentNode) {\n  return commentNode.nodeValue;\n};\n\nexports.getDocumentTypeNodeName = function (doctypeNode) {\n  return doctypeNode.name;\n};\n\nexports.getDocumentTypeNodePublicId = function (doctypeNode) {\n  return doctypeNode.publicId || null;\n};\n\nexports.getDocumentTypeNodeSystemId = function (doctypeNode) {\n  return doctypeNode.systemId || null;\n};\n\n//Node types\nexports.isTextNode = function (node) {\n  return node.nodeName === '#text';\n};\n\nexports.isCommentNode = function (node) {\n  return node.nodeName === '#comment';\n};\n\nexports.isDocumentTypeNode = function (node) {\n  return node.nodeType === 10;\n};\n\nexports.isElementNode = function (node) {\n  return !!node.tagName;\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/helpers/validate-names.js":"\"use strict\";\nvar xnv = require(\"xml-name-validator\");\n\n// https://dom.spec.whatwg.org/#validate\n\nexports.name = function (name, core) {\n  try {\n    xnv.name(name);\n  } catch (e) {\n    throw new core.DOMException(core.DOMException.INVALID_CHARACTER_ERR,\n      \"\\\"\" + name + \"\\\" did not match the Name production: \" + e.message);\n  }\n};\n\nexports.qname = function (qname, core) {\n  exports.name(qname, core);\n\n  try {\n    xnv.qname(qname);\n  } catch (e) {\n    throw new core.DOMException(core.DOMException.NAMESPACE_ERR,\n      \"\\\"\" + qname + \"\\\" did not match the QName production: \" + e.message);\n  }\n};\n\nexports.validateAndExtract = function (namespace, qualifiedName, core) {\n  if (namespace === \"\") {\n    namespace = null;\n  }\n\n  exports.qname(qualifiedName, core);\n\n  var prefix = null;\n  var localName = qualifiedName;\n\n  var colonIndex = qualifiedName.indexOf(\":\");\n  if (colonIndex !== -1) {\n    prefix = qualifiedName.substring(0, colonIndex);\n    localName = qualifiedName.substring(colonIndex + 1);\n  }\n\n  if (prefix !== null && namespace === null) {\n    throw new core.DOMException(core.DOMException.NAMESPACE_ERR,\n      \"A namespace was given but a prefix was also extracted from the qualifiedName\");\n  }\n\n  if (prefix === \"xml\" && namespace !== \"http://www.w3.org/XML/1998/namespace\") {\n    throw new core.DOMException(core.DOMException.NAMESPACE_ERR,\n      \"A prefix of \\\"xml\\\" was given but the namespace was not the XML namespace\");\n  }\n\n  if ((qualifiedName === \"xmlns\" || prefix === \"xmlns\") && namespace !== \"http://www.w3.org/2000/xmlns/\") {\n    throw new core.DOMException(core.DOMException.NAMESPACE_ERR,\n      \"A prefix or qualifiedName of \\\"xmlns\\\" was given but the namespace was not the XMLNS namespace\");\n  }\n\n  if (namespace === \"http://www.w3.org/2000/xmlns/\" && qualifiedName !== \"xmlns\" && prefix !== \"xmlns\") {\n    throw new core.DOMException(core.DOMException.NAMESPACE_ERR,\n      \"The XMLNS namespace was given but neither the prefix nor qualifiedName was \\\"xmlns\\\"\");\n  }\n\n  return { namespace: namespace, prefix: prefix, localName: localName, qualifiedName: qualifiedName };\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/location.js":"\"use strict\";\n\nvar URL = require(\"url\");\nvar resolveHref = require(\"../utils\").resolveHref;\nvar NOT_IMPLEMENTED = require(\"./utils\").NOT_IMPLEMENTED;\n\nmodule.exports = Location;\n\nfunction Location(urlString, document) {\n  this._url = URL.parse(urlString);\n  this._document = document;\n}\n\nLocation.prototype = {\n  constructor: Location,\n  reload: function () {\n    NOT_IMPLEMENTED(\"location.reload\", this._document)();\n  },\n  get protocol() { return this._url.protocol || \":\"; },\n  get host() { return this._url.host || \"\"; },\n  get auth() { return this._url.auth; },\n  get hostname() { return this._url.hostname || \"\"; },\n  get origin() {\n    return ((this._url.protocol !== undefined && this._url.protocol !== null) ?\n              this._url.protocol + \"//\" :\n              this._url.protocol) +\n        this._url.host || \"\";\n  },\n  get port() { return this._url.port || \"\"; },\n  get pathname() { return this._url.pathname || \"\"; },\n  get href() { return this._url.href; },\n  get hash() { return this._url.hash || \"\"; },\n  get search() { return this._url.search || \"\"; },\n\n  set href(val) {\n    var oldUrl = this._url.href;\n    var oldProtocol = this._url.protocol;\n    var oldHost = this._url.host;\n    var oldPathname = this._url.pathname;\n    var oldHash = this._url.hash || \"\";\n\n    this._url = URL.parse(resolveHref(oldUrl, val));\n    var newUrl = this._url.href;\n    var newProtocol = this._url.protocol;\n    var newHost = this._url.host;\n    var newPathname = this._url.pathname;\n    var newHash = this._url.hash || \"\";\n\n    if (oldProtocol === newProtocol && oldHost === newHost && oldPathname === newPathname && oldHash !== newHash) {\n      this._signalHashChange(oldUrl, newUrl);\n    } else {\n      NOT_IMPLEMENTED(\"location.href (no reload)\", this._document)();\n    }\n  },\n\n  set hash(val) {\n    var oldUrl = this._url.href;\n    var oldHash = this._url.hash || \"\";\n\n    if (val.lastIndexOf(\"#\", 0) !== 0) {\n      val = \"#\" + val;\n    }\n\n    this._url = URL.parse(resolveHref(oldUrl, val));\n    var newUrl = this._url.href;\n    var newHash = this._url.hash || \"\";\n\n    if (oldHash !== newHash) {\n      this._signalHashChange(oldUrl, newUrl);\n    }\n  },\n\n  set search(val) {\n    var oldUrl = this._url.href;\n    var oldHash = this._url.hash || \"\";\n    if (val.length) {\n      if (val.lastIndexOf(\"?\", 0) !== 0) {\n        val = \"?\" + val;\n      }\n      this._url = URL.parse(resolveHref(oldUrl, val + oldHash));\n    } else {\n      this._url = URL.parse(oldUrl.replace(/\\?([^#]+)/, \"\"));\n    }\n  },\n\n  replace: function (val) {\n    this.href = val;\n  },\n\n  toString: function () {\n    return this._url.href;\n  },\n\n  _signalHashChange: function (oldUrl, newUrl) {\n    var ev = this._document.createEvent(\"HTMLEvents\");\n    ev.initEvent(\"hashchange\", false, false);\n    ev.oldUrl = oldUrl;\n    ev.newUrl = newUrl;\n    process.nextTick(function () {\n      this._document.parentWindow.dispatchEvent(ev);\n    }.bind(this));\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/utils.js":"\"use strict\";\n\nexports.NOT_IMPLEMENTED = function (nameForErrorMessage, target) {\n  return function () {\n    if (target === undefined) {\n      target = this;\n    }\n\n    if (target && target.raise) {\n      target.raise(\"error\", \"NOT_IMPLEMENTED: \" + nameForErrorMessage);\n    } else if (typeof console !== \"undefined\" && console.log) {\n      console.log(new Error(\"Called NOT_IMPLEMENTED without an element to raise on: \" + nameForErrorMessage));\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level2/core.js":"var core         = require(\"../level1/core\");\nvar defineGetter = require('../utils').defineGetter;\nvar defineSetter = require('../utils').defineSetter;\nvar memoizeQuery = require('../utils').memoizeQuery;\nvar validateQname = require('../living/helpers/validate-names').qname;\nvar validateAndExtract = require('../living/helpers/validate-names').validateAndExtract;\n\ncore.NamedNodeMap.prototype.getNamedItemNS = function(/* string */ namespaceURI,\n                                                      /* string */ localName)\n{\n  if (this._nsStore[namespaceURI] && this._nsStore[namespaceURI][localName]) {\n    return this._nsStore[namespaceURI][localName];\n  }\n  return null;\n};\n\ncore.NamedNodeMap.prototype.setNamedItemNS = function(/* Node */ arg)\n{\n  if (this._readonly) {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n  if (this._ownerDocument !== arg.ownerDocument) {\n    throw new core.DOMException(core.WRONG_DOCUMENT_ERR);\n  }\n\n  if (arg._ownerElement) {\n    throw new core.DOMException(core.INUSE_ATTRIBUTE_ERR);\n  }\n\n  // readonly\n  if (this._readonly === true) {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n\n  if (!this._nsStore[arg.namespaceURI]) {\n    this._nsStore[arg.namespaceURI] = {};\n  }\n  var existing = null;\n  if (this._nsStore[arg.namespaceURI][arg.localName]) {\n    var existing = this._nsStore[arg.namespaceURI][arg.localName];\n  }\n\n  this._nsStore[arg.namespaceURI][arg.localName] = arg;\n\n  arg._ownerDocument = this._ownerDocument;\n\n  return this.setNamedItem(arg);\n};\n\ncore.NamedNodeMap.prototype.removeNamedItemNS = function(/*string */ namespaceURI,\n                                                         /* string */ localName)\n{\n\n  if (this.readonly) {\n    throw new core.DOMException(core.NO_MODIFICATION_ALLOWED_ERR);\n  }\n\n\n  var parent = this._parentNode,\n      found = null,\n      defaults,\n      clone,\n      defaultEl,\n      defaultAttr;\n\n  if (this._nsStore[namespaceURI] &&\n      this._nsStore[namespaceURI][localName])\n  {\n    found = this._nsStore[namespaceURI][localName];\n    this.removeNamedItem(found.qualifiedName);\n    delete this._nsStore[namespaceURI][localName];\n  }\n\n  if (!found) {\n    throw new core.DOMException(core.NOT_FOUND_ERR);\n  }\n\n  return found;\n};\n\ncore.NamedNodeMap.prototype._map = function(fn) {\n  var ret = [], l = this.length, i = 0, node;\n  for(i; i<l; i++) {\n    node = this.item(i);\n    if (fn && fn(node)) {\n      ret.push(node);\n    }\n  }\n  return ret;\n};\n\ncore.Element.prototype.getAttribute = function(/* string */ name)\n{\n  var attr =  this.getAttributeNode(name);\n  return attr && attr.value;\n};\n\ncore.Element.prototype.getAttributeNode = function(/* string */ name)\n{\n  return this._attributes.$getNoNS(name);\n};\n\ncore.Element.prototype.removeAttribute = function(/* string */ name)\n{\n  return this._attributes.$removeNoNS(name);\n};\n\ncore.Element.prototype.getAttributeNS = function(/* string */ namespaceURI,\n                                                 /* string */ localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  var attr =  this._attributes.$getNode(namespaceURI, localName);\n  return attr && attr.value;\n};\n\ncore.Element.prototype.setAttribute = function(/* string */ name,\n                                               /* string */ value)\n{\n  this._attributes.$setNoNS(name, value);\n};\n\ncore.Element.prototype._setAttributeNoValidation = function (name, value) {\n  this._attributes.$setNoNS(name, value, true);\n};\n\ncore.Element.prototype.setAttributeNS = function (namespace, name, value) {\n  namespace = namespace !== null ? String(namespace) : namespace;\n  name = String(name);\n  value = String(value);\n\n  var extracted = validateAndExtract(namespace, name, core);\n\n  this._attributes.$set(extracted.localName, value, extracted.qualifiedName, extracted.prefix, extracted.namespace);\n};\n\ncore.Element.prototype.removeAttributeNS = function(/* string */ namespaceURI,\n                                                    /* string */ localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  this._attributes.$remove(namespaceURI, localName);\n};\n\ncore.Element.prototype.getAttributeNodeNS = function(/* string */ namespaceURI,\n                                                     /* string */ localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  return this._attributes.$getNode(namespaceURI, localName);\n};\n\ncore.Element.prototype.setAttributeNodeNS = function(/* Attr */ newAttr)\n{\n  if (newAttr.ownerElement) {\n    throw new core.DOMException(core.INUSE_ATTRIBUTE_ERR);\n  }\n\n  return this._attributes.$setNode(newAttr);\n};\n\ncore.Element.prototype.getElementsByTagNameNS = memoizeQuery(function(/* String */ namespaceURI,\n                                                         /* String */ localName)\n{\n  var nsPrefixCache = {};\n\n  function filterByTagName(child) {\n    var localMatch = child.localName === localName,\n        nsMatch    = child.namespaceURI === namespaceURI;\n\n    if ((localMatch || localName === \"*\") &&\n        (nsMatch || namespaceURI === \"*\"))\n    {\n      if (child.nodeType === child.ELEMENT_NODE) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return new core.NodeList(this.ownerDocument || this,\n                           core.mapper(this, filterByTagName));\n});\n\ncore.Element.prototype.hasAttribute = function(/* string */name)\n{\n  if (!this._attributes) {\n    return false;\n  }\n\n  // Note: you might think you only need the latter condition. However, it makes a test case fail.\n  // HOWEVER, that test case is for a XML DTD feature called \"default attributes\" that never was implemented by\n  // browsers, so when we remove default attributes, we should be able to fix this code too.\n  return !!this._attributes.$getNoNS(name) || !!this._attributes.$getNoNS(name.toLowerCase());\n};\n\ncore.Element.prototype.hasAttributeNS = function(/* string */namespaceURI,\n                                                 /* string */localName)\n{\n  if (namespaceURI === \"\") {\n    namespaceURI = null;\n  }\n\n  return (this._attributes.getNamedItemNS(namespaceURI, localName) ||\n          this.hasAttribute(localName));\n};\n\ncore.Document.prototype.importNode = function(/* Node */ importedNode,\n                                              /* bool */ deep)\n{\n  if (importedNode && importedNode.nodeType) {\n    if (importedNode.nodeType === this.DOCUMENT_NODE ||\n        importedNode.nodeType === this.DOCUMENT_TYPE_NODE) {\n      throw new core.DOMException(core.NOT_SUPPORTED_ERR);\n    }\n  }\n\n  var self = this,\n      newNode = importedNode.cloneNode(deep, function(a, b) {\n        b._prefix        = a._prefix;\n        b._namespaceURI  = a._namespaceURI;\n        b._localName     = a._localName;\n      });\n\n  function lastChance(el) {\n    var attr, defaultEl, i, len;\n\n    el._ownerDocument = self;\n    if (el.id) {\n      if (!self._ids) {self._ids = {};}\n      if (!self._ids[el.id]) {self._ids[el.id] = [];}\n      self._ids[el.id].push(el);\n    }\n    if (el._attributes) {\n      var drop = [];\n      el._attributes._ownerDocument = self;\n      for (i=0,len=el._attributes.length; i < len; i++) {\n        attr = el._attributes[i];\n        attr._ownerDocument = self;\n      }\n\n      // Remove obsolete default nodes.\n      for(i = 0; i < drop.length; ++i) {\n        el._attributes.$removeNode(drop[i]);\n      }\n\n    }\n  }\n\n  if (deep) {\n    core.visitTree(newNode, lastChance);\n  }\n  else {\n    lastChance(newNode);\n  }\n\n  return newNode;\n};\n\ncore.Document.prototype.createElementNS = function (namespace, qualifiedName) {\n  namespace = namespace !== null ? String(namespace) : namespace;\n  qualifiedName = String(qualifiedName);\n\n  var extracted = validateAndExtract(namespace, qualifiedName, core);\n  var element = this.createElement(extracted.localName);\n  element._namespaceURI = extracted.namespace;\n  element._prefix = extracted.prefix;\n\n  return element;\n};\n\ncore.Document.prototype.createAttributeNS = function (namespace, qualifiedName) {\n  namespace = namespace !== null ? String(namespace) : namespace;\n  qualifiedName = String(qualifiedName);\n\n  var extracted = validateAndExtract(namespace, qualifiedName, core);\n  attribute = this.createAttribute(extracted.qualifiedName);\n\n  attribute._namespaceURI = extracted.namespace;\n  attribute._prefix = extracted.prefix;\n  attribute._localName = extracted.localName;\n  attribute._name = extracted.qualifiedName;\n\n  return attribute;\n};\n\ncore.Document.prototype.getElementsByTagNameNS = function(/* String */ namespaceURI,\n                                                          /* String */ localName)\n{\n  return core.Element.prototype.getElementsByTagNameNS.call(this,\n                                                            namespaceURI,\n                                                            localName);\n};\n\ncore.Document.prototype.getElementById = function(id) {\n  // return the first element\n  return (this._ids && this._ids[id] && this._ids[id].length > 0 ? this._ids[id][0] : null);\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level2/events.js":"/* DOM Level2 Events implemented as described here:\n *\n * http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html\n *\n */\nvar core = require(\"../level1/core\"),\n    utils = require(\"../utils\"),\n    defineGetter = utils.defineGetter,\n    defineSetter = utils.defineSetter,\n    inheritFrom = utils.inheritFrom;\n\ncore.EventException = function() {\n    if (arguments.length > 0) {\n        this._code = arguments[0];\n    } else {\n        this._code = 0;\n    }\n    if (arguments.length > 1) {\n        this._message = arguments[1];\n    } else {\n        this._message = \"Unspecified event type\";\n    }\n    Error.call(this, this._message);\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, core.EventException);\n    }\n};\ninheritFrom(Error, core.EventException, {\n  UNSPECIFIED_EVENT_TYPE_ERR : 0,\n  get code() { return this._code;}\n});\n\ncore.Event = function(eventType) {\n    this._eventType = eventType;\n    this._type = null;\n    this._bubbles = null;\n    this._cancelable = null;\n    this._target = null;\n    this._currentTarget = null;\n    this._eventPhase = 0;\n    this._timeStamp = null;\n    this._preventDefault = false;\n    this._stopPropagation = false;\n};\ncore.Event.prototype = {\n    initEvent: function(type, bubbles, cancelable) {\n        this._type = type;\n        this._bubbles = bubbles;\n        this._cancelable = cancelable;\n    },\n    preventDefault: function() {\n        if (this._cancelable) {\n            this._preventDefault = true;\n        }\n    },\n    stopPropagation: function() {\n        this._stopPropagation = true;\n    },\n    NONE            : 0,\n    CAPTURING_PHASE : 1,\n    AT_TARGET       : 2,\n    BUBBLING_PHASE  : 3,\n    get eventType() { return this._eventType; },\n    get type() { return this._type; },\n    get bubbles() { return this._bubbles; },\n    get cancelable() { return this._cancelable; },\n    get target() { return this._target; },\n    get currentTarget() { return this._currentTarget; },\n    get eventPhase() { return this._eventPhase; },\n    get timeStamp() { return this._timeStamp; }\n};\n\n\ncore.UIEvent = function(eventType) {\n    core.Event.call(this, eventType);\n    this.view = null;\n    this.detail = null;\n};\ninheritFrom(core.Event, core.UIEvent, {\n    initUIEvent: function(type, bubbles, cancelable, view, detail) {\n        this.initEvent(type, bubbles, cancelable);\n        this.view = view;\n        this.detail = detail;\n    },\n});\n\n\ncore.MouseEvent = function(eventType) {\n    core.UIEvent.call(this, eventType);\n    this.screenX = null;\n    this.screenY = null;\n    this.clientX = null;\n    this.clientY = null;\n    this.ctrlKey = null;\n    this.shiftKey = null;\n    this.altKey = null;\n    this.metaKey = null;\n    this.button = null;\n    this.relatedTarget = null;\n};\ninheritFrom(core.UIEvent, core.MouseEvent, {\n    initMouseEvent:   function(type,\n                               bubbles,\n                               cancelable,\n                               view,\n                               detail,\n                               screenX,\n                               screenY,\n                               clientX,\n                               clientY,\n                               ctrlKey,\n                               altKey,\n                               shiftKey,\n                               metaKey,\n                               button,\n                               relatedTarget) {\n        this.initUIEvent(type, bubbles, cancelable, view, detail);\n        this.screenX  = screenX\n        this.screenY  = screenY\n        this.clientX  = clientX\n        this.clientY  = clientY\n        this.ctrlKey  = ctrlKey\n        this.shiftKey  = shiftKey\n        this.altKey  = altKey\n        this.metaKey  = metaKey\n        this.button  = button\n        this.relatedTarget  = relatedTarget\n    }\n});\n\n\ncore.MutationEvent = function(eventType) {\n    core.Event.call(this, eventType);\n    this.relatedNode = null;\n    this.prevValue = null;\n    this.newValue = null;\n    this.attrName = null;\n    this.attrChange = null;\n};\ninheritFrom(core.Event, core.MutationEvent, {\n    initMutationEvent:   function(type,\n                                  bubbles,\n                                  cancelable,\n                                  relatedNode,\n                                  prevValue,\n                                  newValue,\n                                  attrName,\n                                  attrChange) {\n        this.initEvent(type, bubbles, cancelable);\n        this.relatedNode = relatedNode;\n        this.prevValue = prevValue;\n        this.newValue = newValue;\n        this.attrName = attrName;\n        this.attrChange = attrChange;\n    },\n    MODIFICATION : 1,\n    ADDITION     : 2,\n    REMOVAL      : 3\n});\n\ncore.EventTarget = function() {};\n\nfunction getListeners(target, type, capturing) {\n    var listeners = target._listeners\n            && target._listeners[type]\n            && target._listeners[type][capturing] || [];\n    if (!capturing) {\n        var traditionalHandler = target['on' + type];\n        if (traditionalHandler) {\n            var implementation = (target._ownerDocument ? target._ownerDocument.implementation\n                                                        : target.document.implementation);\n\n            if (implementation._hasFeature('ProcessExternalResources', 'script')) {\n                if (listeners.indexOf(traditionalHandler) < 0) {\n                    listeners.push(traditionalHandler);\n                }\n            }\n        }\n    }\n    return listeners;\n}\n\nfunction dispatchPhase(event, iterator) {\n    var target = iterator();\n\n    while (target && !event._stopPropagation) {\n        if (event._eventPhase === event.CAPTURING_PHASE || event._eventPhase === event.AT_TARGET) {\n            callListeners(event, target, getListeners(target, event._type, true));\n        }\n        if (event._eventPhase === event.AT_TARGET || event._eventPhase === event.BUBBLING_PHASE) {\n            callListeners(event, target, getListeners(target, event._type, false));\n        }\n        target = iterator();\n    }\n}\n\nfunction callListeners(event, target, listeners) {\n    var currentListener = listeners.length;\n    while (currentListener--) {\n        event._currentTarget = target;\n        try {\n          listeners[currentListener].call(target, event);\n        } catch (e) {\n          target.raise(\n            'error', \"Dispatching event '\" + event._type + \"' failed\",\n            {error: e, event: event}\n          );\n        }\n    }\n}\n\nfunction forwardIterator(list) {\n  var i = 0, len = list.length;\n  return function iterator() { return i < len ? list[i++] : null };\n}\n\nfunction backwardIterator(list) {\n  var i = list.length;\n  return function iterator() { return i >=0 ? list[--i] : null };\n}\n\nfunction singleIterator(obj) {\n  var i = 1;\n  return function iterator() { return i-- ? obj : null };\n}\n\ncore.EventTarget.prototype = {\n    addEventListener: function(type, listener, capturing) {\n        this._listeners = this._listeners || {};\n        var listeners = this._listeners[type] || {};\n        capturing = (capturing === true);\n        var capturingListeners = listeners[capturing] || [];\n        for (var i=0; i < capturingListeners.length; i++) {\n            if (capturingListeners[i] === listener) {\n                return;\n            }\n        }\n        capturingListeners.push(listener);\n        listeners[capturing] = capturingListeners;\n        this._listeners[type] = listeners;\n    },\n\n    removeEventListener: function(type, listener, capturing) {\n        var listeners  = this._listeners && this._listeners[type];\n        if (!listeners) return;\n        var capturingListeners = listeners[(capturing === true)];\n        if (!capturingListeners) return;\n        for (var i=0; i < capturingListeners.length; i++) {\n            if (capturingListeners[i] === listener) {\n                capturingListeners.splice(i, 1);\n                return;\n            }\n        }\n    },\n\n    dispatchEvent: function(event) {\n        if (event == null) {\n            throw new core.EventException(0, \"Null event\");\n        }\n        if (event._type == null || event._type == \"\") {\n            throw new core.EventException(0, \"Uninitialized event\");\n        }\n\n        var targetList = [];\n\n        event._target = this;\n\n        //per the spec we gather the list of targets first to ensure\n        //against dom modifications during actual event dispatch\n        var target = this,\n            targetParent = target._parentNode;\n        while (targetParent) {\n            targetList.push(targetParent);\n            target = targetParent;\n            targetParent = target._parentNode;\n        }\n        targetParent = target._parentWindow;\n        if (targetParent) {\n            targetList.push(targetParent);\n        }\n\n        var iterator = backwardIterator(targetList);\n\n        event._eventPhase = event.CAPTURING_PHASE;\n        dispatchPhase(event, iterator);\n\n        iterator = singleIterator(event._target);\n        event._eventPhase = event.AT_TARGET;\n        dispatchPhase(event, iterator);\n\n        if (event._bubbles) {\n            iterator = forwardIterator(targetList);\n            event._eventPhase = event.BUBBLING_PHASE;\n            dispatchPhase(event, iterator);\n        }\n\n        event._currentTarget = null;\n        event._eventPhase = event.NONE;\n\n        return !event._preventDefault;\n    }\n\n};\n\n// Reinherit class heirarchy with EventTarget at its root\ninheritFrom(core.EventTarget, core.Node, core.Node.prototype);\n\n// Node\ninheritFrom(core.Node, core.Attr, core.Attr.prototype);\ninheritFrom(core.Node, core.Document, core.Document.prototype);\ninheritFrom(core.Node, core.DocumentFragment, core.DocumentFragment.prototype);\ninheritFrom(core.Node, core.Element, core.Element.prototype);\n\n\nfunction getDocument(el) {\n  return el.nodeType == core.Node.DOCUMENT_NODE ? el : el._ownerDocument;\n}\n\nfunction mutationEventsEnabled(el) {\n  return el.nodeType != core.Node.ATTRIBUTE_NODE &&\n         getDocument(el).implementation._hasFeature('MutationEvents');\n}\n\nvar insertBefore_super = core.Node.prototype.insertBefore;\ncore.Node.prototype.insertBefore = function(newChild, refChild) {\n  var ret = insertBefore_super.apply(this, arguments);\n  if (mutationEventsEnabled(this)) {\n    var doc = getDocument(this),\n        ev = doc.createEvent(\"MutationEvents\");\n\n    ev.initMutationEvent(\"DOMNodeInserted\", true, false, this, null, null, null, null);\n    newChild.dispatchEvent(ev);\n    if (this.nodeType == core.Node.DOCUMENT_NODE || this._attachedToDocument) {\n      ev = doc.createEvent(\"MutationEvents\");\n      ev.initMutationEvent(\"DOMNodeInsertedIntoDocument\", false, false, null, null, null, null, null);\n      core.visitTree(newChild, function(el) {\n        if (el.nodeType == core.Node.ELEMENT_NODE) {\n          el.dispatchEvent(ev);\n          el._attachedToDocument = true;\n        }\n      });\n    }\n  }\n  return ret;\n};\n\nvar removeChild_super = core.Node.prototype.removeChild;\ncore.Node.prototype.removeChild = function (oldChild) {\n  if (mutationEventsEnabled(this)) {\n    var doc = getDocument(this),\n        ev = doc.createEvent(\"MutationEvents\");\n\n    ev.initMutationEvent(\"DOMNodeRemoved\", true, false, this, null, null, null, null);\n    oldChild.dispatchEvent(ev);\n\n    ev = doc.createEvent(\"MutationEvents\");\n    ev.initMutationEvent(\"DOMNodeRemovedFromDocument\", false, false, null, null, null, null, null);\n    core.visitTree(oldChild, function(el) {\n      if (el.nodeType == core.Node.ELEMENT_NODE) {\n        el.dispatchEvent(ev);\n        el._attachedToDocument = false;\n      }\n    });\n  }\n  return removeChild_super.apply(this, arguments);\n};\n\nfunction dispatchAttrEvent(doc, target, prevVal, newVal, attrName, attrChange) {\n  if (!newVal || newVal != prevVal) {\n    var ev = doc.createEvent(\"MutationEvents\");\n    ev.initMutationEvent(\"DOMAttrModified\", true, false, target, prevVal,\n                         newVal, attrName, attrChange);\n    target.dispatchEvent(ev);\n  }\n}\n\nfunction attrNodeInterceptor(_super, change) {\n  return function(node) {\n    var target = this._parentNode,\n        prev = _super.apply(this, arguments);\n\n    if (mutationEventsEnabled(target)) {\n      dispatchAttrEvent(target._ownerDocument,\n                        target,\n                        prev && prev.value || null,\n                        change == 'ADDITION' ? node.value : null,\n                        prev && prev.name || node.name,\n                        core.MutationEvent.prototype[change]);\n    }\n\n    return prev;\n  };\n}\n\nfunction attrInterceptor(_super, ns) {\n  return function(localName, value, _name, _prefix, _namespace) {\n    var target = this._parentNode,\n        namespace = _namespace; // do not reassign parameters when using \"arguments\" (performance)\n\n    if (!mutationEventsEnabled(target)) {\n      _super.apply(this, arguments);\n      return;\n    }\n\n    if (namespace === undefined) {\n        namespace = null;\n    }\n\n    var prev =\n          ns ? this.$getNode(namespace, localName) : this.$getNoNS(localName);\n    var prevVal = prev && prev.value || null;\n\n    _super.apply(this, arguments);\n\n    var node = ns ? this.$getNode(namespace, localName):\n            this.$getNoNS(localName);\n\n    dispatchAttrEvent(target._ownerDocument,\n                      target,\n                      prevVal,\n                      node.value,\n                      node.name,\n                      core.MutationEvent.prototype.ADDITION);\n  };\n}\n\n\ncore.AttributeList.prototype.$removeNode = attrNodeInterceptor(core.AttributeList.prototype.$removeNode, 'REMOVAL');\ncore.AttributeList.prototype.$setNode = attrNodeInterceptor(core.AttributeList.prototype.$setNode, 'ADDITION');\ncore.AttributeList.prototype.$set = attrInterceptor(core.AttributeList.prototype.$set, true);\ncore.AttributeList.prototype.$setNoNS = attrInterceptor(core.AttributeList.prototype.$setNoNS, false);\n\ncore.Document.prototype.createEvent = function(eventType) {\n    switch (eventType) {\n        case \"MutationEvents\": return new core.MutationEvent(eventType);\n        case \"UIEvents\": return new core.UIEvent(eventType);\n        case \"MouseEvents\": return new core.MouseEvent(eventType);\n        case \"HTMLEvents\": return new core.Event(eventType);\n    }\n    return new core.Event(eventType);\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level2/html.js":"var core                  = require(\"../level1/core\"),\n    applyDocumentFeatures = require('../browser/documentfeatures').applyDocumentFeatures,\n    defineGetter          = require('../utils').defineGetter,\n    defineSetter          = require('../utils').defineSetter,\n    inheritFrom           = require(\"../utils\").inheritFrom,\n    resolveHref           = require(\"../utils\").resolveHref,\n    URL                   = require(\"url\"),\n    Path                  = require('path'),\n    fs                    = require(\"fs\"),\n    http                  = require('http'),\n    https                 = require('https');\n\nvar isBrowser = Object.prototype.toString.call(process) !== \"[object process]\";\n\n// Setup the javascript language processor\ncore.languageProcessors = {\n  javascript : require(\"./languages/javascript\").javascript\n};\n\ncore.resourceLoader = {\n  load: function(element, href, callback) {\n    var ownerDoc = element._ownerDocument;\n    var ownerImplementation = ownerDoc.implementation;\n\n    if (ownerImplementation._hasFeature('FetchExternalResources', element.tagName.toLowerCase())) {\n      var full = this.resolve(ownerDoc, href);\n      var url = URL.parse(full);\n      if (ownerImplementation._hasFeature('SkipExternalResources', full)) {\n        return false;\n      }\n\n      var cookie = ownerDoc.cookie;\n      var cookieDomain = ownerDoc._cookieDomain;\n      var baseUrl = this.baseUrl(ownerDoc);\n      var enqueued = this.enqueue(element, callback, full);\n\n      if (typeof ownerDoc._resourceLoader == 'function') {\n        var fetch = this.fetch.bind(this);\n        ownerDoc._resourceLoader.call(null, {\n          url: url,\n          cookie: cookie,\n          cookieDomain: cookieDomain,\n          baseUrl: baseUrl,\n          defaultFetch: function(callback) {\n            fetch(this.url, this.cookie, this.cookieDomain, this.baseUrl, callback);\n          }\n        }, enqueued);\n      } else {\n        this.fetch(url, cookie, cookieDomain, baseUrl, enqueued);\n      }\n    }\n  },\n  enqueue: function(element, callback, filename) {\n    var loader = this,\n        doc    = element.nodeType === core.Node.DOCUMENT_NODE ?\n                 element                :\n                 element._ownerDocument;\n\n    if (!doc._queue) {\n      return function() {};\n    }\n\n    return doc._queue.push(function(err, data) {\n      var ev = doc.createEvent('HTMLEvents');\n\n      if (!err) {\n        try {\n          callback.call(element, data, filename || doc.URL);\n          ev.initEvent('load', false, false);\n        }\n        catch(e) {\n          err = e;\n        }\n      }\n\n      if (err) {\n        ev.initEvent('error', false, false);\n        ev.error = err;\n      }\n\n      element.dispatchEvent(ev);\n    });\n  },\n\n  baseUrl: function(document) {\n    var baseElements = document.getElementsByTagName('base');\n    var baseUrl = document.URL;\n\n    if (baseElements.length > 0) {\n      var baseHref = baseElements.item(0).href;\n      if (baseHref) {\n        baseUrl = resolveHref(baseUrl, baseHref);\n      }\n    }\n\n    return baseUrl;\n  },\n  resolve: function(document, href) {\n    // if getAttribute returns null, there is no href\n    // lets resolve to an empty string (nulls are not expected farther up)\n    if (href === null) {\n      return '';\n    }\n\n    var baseUrl = this.baseUrl(document);\n\n    return resolveHref(baseUrl, href);\n  },\n  fetch: function(url, cookie, cookieDomain, referrer, callback) {\n    if (url.hostname) {\n      this.download(url, cookie, cookieDomain, referrer, callback);\n    } else {\n      this.readFile(url.pathname, callback);\n    }\n  },\n  download: function(url, cookie, cookieDomain, referrer, callback) {\n    var path    = (url.pathname || '') + (url.search || ''),\n        options = {'method': 'GET', 'host': url.hostname, 'path': path},\n        request;\n    if (url.protocol === 'https:') {\n      options.port = url.port || 443;\n      request = https.request(options);\n    } else {\n      options.port = url.port || 80;\n      request = http.request(options);\n    }\n\n    // set header; accomodate browserify\n    if (referrer && !isBrowser) {\n        request.setHeader('Referer', referrer);\n    }\n    if (cookie) {\n      var host = url.host.split(':')[0];\n      if (host.indexOf(cookieDomain, host.length - cookieDomain.length) !== -1) {\n        request.setHeader('cookie', cookie);\n      }\n    }\n\n    request.on('response', function (response) {\n      var data = '';\n      function success () {\n        if ([301, 302, 303, 307].indexOf(response.statusCode) > -1) {\n          var redirect = URL.resolve(url, response.headers[\"location\"]);\n          core.resourceLoader.download(URL.parse(redirect), cookie, cookieDomain, referrer, callback);\n        } else {\n          callback(null, data);\n        }\n      }\n\n      // Accomodate browserify\n      if (response.setEncoding) {\n        response.setEncoding('utf8');\n      }\n\n      response.on('data', function (chunk) {\n        data += chunk.toString();\n      });\n      response.on('end', function() {\n        // According to node docs, 'close' can fire after 'end', but not\n        // vice versa.  Remove 'close' listener so we don't call success twice.\n        response.removeAllListeners('close');\n        success();\n      });\n      response.on('close', function (err) {\n        if (err) {\n          callback(err);\n        } else {\n          success();\n        }\n      });\n    });\n\n    request.on('error', callback);\n    request.end();\n  },\n  readFile: function(url, callback) {\n    fs.readFile(url.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, '$1:/').replace(/%20/g, ' '), 'utf8', callback);\n  }\n};\n\nfunction define(elementClass, def) {\n  var tagName = def.tagName,\n    tagNames = def.tagNames || (tagName? [tagName] : []),\n    parentClass = def.parentClass || core.HTMLElement,\n    attrs = def.attributes || [],\n    proto = def.proto || {};\n\n  var elem = core[elementClass] = function(document, name) {\n    parentClass.call(this, document, name || tagName.toUpperCase());\n    if (elem._init) {\n      elem._init.call(this);\n    }\n  };\n  elem._init = def.init;\n\n  inheritFrom(parentClass, elem, proto);\n\n  attrs.forEach(function(n) {\n      var prop = n.prop || n,\n        attr = n.attr || prop.toLowerCase();\n\n      if (!n.prop || n.read !== false) {\n        defineGetter(elem.prototype, prop, function() {\n          var s = this.getAttribute(attr);\n          if (n.type && n.type === 'boolean') {\n            return s !== null;\n          }\n          if (n.type && n.type === 'long') {\n            return +s;\n          }\n          if (typeof n === 'object' && n.normalize) { // see GH-491\n            return n.normalize(s);\n          }\n          if (s === null) {\n            s = '';\n          }\n          return s;\n        });\n      }\n\n      if (!n.prop || n.write !== false) {\n        defineSetter(elem.prototype, prop, function(val) {\n          if (!val) {\n            this.removeAttribute(attr);\n          }\n          else {\n            var s = val.toString();\n            if (typeof n === 'object' && n.normalize) {\n              s = n.normalize(s);\n            }\n            this.setAttribute(attr, s);\n          }\n        });\n      }\n  });\n\n  tagNames.forEach(function(tag) {\n    core.Document.prototype._elementBuilders[tag.toLowerCase()] = function(doc, s) {\n      var el = new elem(doc, s);\n\n      if (def.elementBuilder) {\n        return def.elementBuilder(el, doc, s);\n      }\n\n      return el;\n    };\n  });\n}\n\n\n\ncore.HTMLCollection = function HTMLCollection(element, query) {\n  this._keys = [];\n  core.NodeList.call(this, element, query);\n};\ninheritFrom(core.NodeList, core.HTMLCollection, {\n  namedItem: function(name) {\n    // Try property shortcut; should work in most cases\n    if (Object.prototype.hasOwnProperty.call(this, name)) {\n      return this[name];\n    }\n\n    var results = this._toArray(),\n        l       = results.length,\n        node,\n        matchingName = null;\n\n    for (var i=0; i<l; i++) {\n      node = results[i];\n      if (node.getAttribute('id') === name) {\n        return node;\n      } else if (node.getAttribute('name') === name) {\n        matchingName = node;\n      }\n    }\n    return matchingName;\n  },\n  toString: function() {\n    return '[ jsdom HTMLCollection ]: contains ' + this.length + ' items';\n  },\n  _resetTo: function(array) {\n    var i, _this = this;\n\n    for (i = 0; i < this._keys.length; ++i) {\n      delete this[this._keys[i]];\n    }\n    this._keys = [];\n\n    core.NodeList.prototype._resetTo.apply(this, arguments);\n\n    function testAttr(node, attr) {\n      var val = node.getAttribute(attr);\n      if (val && !Object.prototype.hasOwnProperty.call(_this, val)) {\n        _this[val] = node;\n        _this._keys.push(val);\n      }\n    }\n    for (i = 0; i < array.length; ++i) {\n      testAttr(array[i], 'id');\n    }\n    for (i = 0; i < array.length; ++i) {\n      testAttr(array[i], 'name');\n    }\n  }\n});\nObject.defineProperty(core.HTMLCollection.prototype, 'constructor', {\n  value: core.NodeList,\n  writable: true,\n  configurable: true\n});\n\ncore.HTMLOptionsCollection = core.HTMLCollection;\n\nfunction closest(e, tagName) {\n  tagName = tagName.toUpperCase();\n  while (e) {\n    if (e.nodeName.toUpperCase() === tagName ||\n        (e.tagName && e.tagName.toUpperCase() === tagName))\n    {\n      return e;\n    }\n    e = e._parentNode;\n  }\n  return null;\n}\n\nfunction descendants(e, tagName, recursive) {\n  var owner = recursive ? e._ownerDocument || e : e;\n  return new core.HTMLCollection(owner, core.mapper(e, function(n) {\n    return n.tagName === tagName;\n  }, recursive));\n}\n\nfunction firstChild(e, tagName) {\n  if (!e) {\n    return null;\n  }\n  var c = descendants(e, tagName, false);\n  return c.length > 0 ? c[0] : null;\n}\n\nfunction ResourceQueue(paused) {\n  this.paused = !!paused;\n}\nResourceQueue.prototype = {\n  push: function(callback) {\n    var q = this;\n    var item = {\n      prev: q.tail,\n      check: function() {\n        if (!q.paused && !this.prev && this.fired){\n          callback(this.err, this.data);\n          if (this.next) {\n            this.next.prev = null;\n            this.next.check();\n          }else{//q.tail===this\n      q.tail = null;\n    }\n        }\n      }\n    };\n    if (q.tail) {\n      q.tail.next = item;\n    }\n    q.tail = item;\n    return function(err, data) {\n      item.fired = 1;\n      item.err = err;\n      item.data = data;\n      item.check();\n    };\n  },\n  resume: function() {\n    if(!this.paused){\n      return;\n    }\n    this.paused = false;\n    var head = this.tail;\n    while(head && head.prev){\n      head = head.prev;\n    }\n    if(head){\n      head.check();\n    }\n  }\n};\n\ncore.HTMLDocument = function HTMLDocument(options) {\n  core.Document.call(this, options);\n  this._referrer = options.referrer;\n  this._cookie = options.cookie;\n  this._cookieDomain = options.cookieDomain || '127.0.0.1';\n  this._documentRoot = options.documentRoot || Path.dirname(this._URL);\n  this._queue = new ResourceQueue(options.deferClose);\n  this._resourceLoader = options.resourceLoader;\n  this.readyState = 'loading';\n\n  // Add level2 features\n  this.implementation._addFeature('core'  , '2.0');\n  this.implementation._addFeature('html'  , '2.0');\n  this.implementation._addFeature('xhtml' , '2.0');\n  this.implementation._addFeature('xml'   , '2.0');\n};\n\ninheritFrom(core.Document, core.HTMLDocument, {\n  _referrer : \"\",\n  get referrer() {\n    return this._referrer || '';\n  },\n  get domain() {\n    return \"\";\n  },\n  get images() {\n    return this.getElementsByTagName('IMG');\n  },\n  get applets() {\n    return new core.HTMLCollection(this, core.mapper(this, function(el) {\n      if (el && el.tagName) {\n        var upper = el.tagName.toUpperCase();\n        if (upper === \"APPLET\") {\n          return true;\n        } else if (upper === \"OBJECT\" &&\n          el.getElementsByTagName('APPLET').length > 0)\n        {\n          return true;\n        }\n      }\n    }));\n  },\n  get links() {\n    return new core.HTMLCollection(this, core.mapper(this, function(el) {\n      if (el && el.tagName) {\n        var upper = el.tagName.toUpperCase();\n        if (upper === \"AREA\" || (upper === \"A\" && el.href)) {\n          return true;\n        }\n      }\n    }));\n  },\n  get forms() {\n    return this.getElementsByTagName('FORM');\n  },\n  get anchors() {\n    return this.getElementsByTagName('A');\n  },\n  open  : function() {\n    this._childNodes = [];\n    this._documentElement = null;\n    this._modified();\n  },\n  close : function() {\n    this._queue.resume();\n    // Set the readyState to 'complete' once all resources are loaded.\n    // As a side-effect the document's load-event will be dispatched.\n    core.resourceLoader.enqueue(this, function() {\n      this.readyState = 'complete';\n      var ev = this.createEvent('HTMLEvents');\n      ev.initEvent('DOMContentLoaded', false, false);\n      this.dispatchEvent(ev);\n    })(null, true);\n  },\n\n  // document.write is defined in browser/index.js.\n\n  writeln : function(text) {\n    this.write(text + '\\n');\n  },\n\n  getElementsByName : function(elementName) {\n    return new core.HTMLCollection(this, core.mapper(this, function(el) {\n      return (el.getAttribute && el.getAttribute(\"name\") === elementName);\n    }));\n  },\n\n  get title() {\n    var head = this.head,\n      title = head ? firstChild(head, 'TITLE') : null;\n    return title ? title.textContent : '';\n  },\n\n  set title(val) {\n    var title = firstChild(this.head, 'TITLE');\n    if (!title) {\n      title = this.createElement('TITLE');\n      var head = this.head;\n      if (!head) {\n        head = this.createElement('HEAD');\n        this.documentElement.insertBefore(head, this.documentElement.firstChild);\n      }\n      head.appendChild(title);\n    }\n    title.textContent = val;\n  },\n\n  get head() {\n    return firstChild(this.documentElement, 'HEAD');\n  },\n\n  set head(unused) { /* noop */ },\n\n  get body() {\n    var body = firstChild(this.documentElement, 'BODY');\n    if (!body) {\n      body = firstChild(this.documentElement, 'FRAMESET');\n    }\n    return body;\n  },\n\n  _cookie : \"\",\n  get cookie() {\n    var cookies = Array.isArray(this._cookie) ?\n      this._cookie :\n      (this._cookie && this._cookie.length > 0 ? [this._cookie] : []);\n\n    return cookies.map(function (x) {\n      return x.split(';')[0];\n    }).join('; ');\n  },\n  set cookie(val) {\n    if (val == null) return val;\n    var key = val.split('=')[0];\n    var cookies = Array.isArray(this._cookie) ?\n      this._cookie :\n      (this._cookie && this._cookie.length > 0 ? [this._cookie] : []);\n    for (var i = 0; i < cookies.length; i++) {\n      if (cookies[i].lastIndexOf(key + '=', 0) === 0) {\n        cookies[i] = val;\n        key = null;\n        break;\n      }\n    }\n    if (key) {\n      cookies.push(val);\n    }\n    if (cookies.length === 1) {\n      this._cookie = cookies[0];\n    } else {\n      this._cookie = cookies;\n    }\n    return val;\n  }\n});\n\ndefine('HTMLElement', {\n  parentClass: core.Element,\n  proto : {\n    // Add default event behavior (click link to navigate, click button to submit\n    // form, etc). We start by wrapping dispatchEvent so we can forward events to\n    // the element's _eventDefault function (only events that did not incur\n    // preventDefault).\n    dispatchEvent : function (event) {\n      var outcome = core.Node.prototype.dispatchEvent.call(this, event)\n\n      if (!event._preventDefault     &&\n          event.target._eventDefaults[event.type] &&\n          typeof event.target._eventDefaults[event.type] === 'function')\n      {\n        event.target._eventDefaults[event.type](event)\n      }\n      return outcome;\n    },\n    getBoundingClientRect: function () {\n      return {\n        bottom: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        width: 0\n      };\n    },\n    focus : function() {\n      this._ownerDocument.activeElement = this;\n    },\n    blur : function() {\n      this._ownerDocument.activeElement = this._ownerDocument.body;\n    },\n    _eventDefaults : {}\n  },\n  attributes: [\n    'id',\n    'title',\n    'lang',\n    'dir',\n    {prop: 'className', attr: 'class', normalize: function(s) { return s || ''; }}\n  ]\n});\n\ncore.Document.prototype._defaultElementBuilder = function(document, tagName) {\n  return new core.HTMLElement(document, tagName);\n};\n\n// http://www.whatwg.org/specs/web-apps/current-work/#category-listed\nvar listedElements = /button|fieldset|input|keygen|object|select|textarea/i;\n\ndefine('HTMLFormElement', {\n  tagName: 'FORM',\n  proto: {\n    _descendantAdded: function(parent, child) {\n      var form = this;\n      core.visitTree(child, function(el) {\n        if (typeof el._changedFormOwner === 'function') {\n          el._changedFormOwner(form);\n        }\n      });\n\n      core.HTMLElement.prototype._descendantAdded.apply(this, arguments);\n    },\n    _descendantRemoved: function(parent, child) {\n      core.visitTree(child, function(el) {\n        if (typeof el._changedFormOwner === 'function') {\n          el._changedFormOwner(null);\n        }\n      });\n\n      core.HTMLElement.prototype._descendantRemoved.apply(this, arguments);\n    },\n    get elements() {\n      return new core.HTMLCollection(this._ownerDocument, core.mapper(this, function(e) {\n        return listedElements.test(e.nodeName) ; // TODO exclude <input type=\"image\">\n      }));\n    },\n    get length() {\n      return this.elements.length;\n    },\n    _dispatchSubmitEvent: function() {\n      var ev = this._ownerDocument.createEvent('HTMLEvents');\n      ev.initEvent('submit', true, true);\n      if (!this.dispatchEvent(ev)) {\n        this.submit();\n      };\n    },\n    submit: function() {\n    },\n    reset: function() {\n      this.elements._toArray().forEach(function(el) {\n        if (typeof el._formReset === 'function') {\n          el._formReset();\n        }\n      });\n    }\n  },\n  attributes: [\n    'name',\n    {prop: 'acceptCharset', attr: 'accept-charset'},\n    'action',\n    'enctype',\n    'method',\n    'target'\n  ]\n});\n\ndefine('HTMLLinkElement', {\n  tagName: 'LINK',\n  proto: {\n    get href() {\n      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute('href'));\n    }\n  },\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'charset',\n    'href',\n    'hreflang',\n    'media',\n    'rel',\n    'rev',\n    'target',\n    'type'\n  ]\n});\n\ndefine('HTMLMetaElement', {\n  tagName: 'META',\n  attributes: [\n    'content',\n    {prop: 'httpEquiv', attr: 'http-equiv'},\n    'name',\n    'scheme'\n  ]\n});\n\ndefine('HTMLHtmlElement', {\n  tagName: 'HTML',\n  attributes: [\n    'version'\n  ]\n});\n\ndefine('HTMLHeadElement', {\n  tagName: 'HEAD',\n  attributes: [\n    'profile'\n  ]\n});\n\ndefine('HTMLTitleElement', {\n  tagName: 'TITLE',\n  proto: {\n    get text() {\n      return this.innerHTML;\n    },\n    set text(s) {\n      this.innerHTML = s;\n    }\n  }\n});\n\ndefine('HTMLBaseElement', {\n  tagName: 'BASE',\n  attributes: [\n    'href',\n    'target'\n  ]\n});\n\n\n//**Deprecated**\ndefine('HTMLIsIndexElement', {\n  tagName : 'ISINDEX',\n  parentClass : core.Element,\n  proto : {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  },\n  attributes : [\n    'prompt'\n  ]\n});\n\n\ndefine('HTMLStyleElement', {\n  tagName: 'STYLE',\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'media',\n    'type',\n  ]\n});\n\ndefine('HTMLBodyElement', {\n  proto: (function() {\n    var proto = {};\n    // The body element's \"traditional\" event handlers are proxied to the\n    // window object.\n    // See: http://www.whatwg.org/specs/web-apps/current-work/#the-body-element\n    ['onafterprint', 'onbeforeprint', 'onbeforeunload', 'onblur', 'onerror',\n     'onfocus', 'onhashchange', 'onload', 'onmessage', 'onoffline', 'ononline',\n     'onpagehide', 'onpageshow', 'onpopstate', 'onresize', 'onscroll',\n     'onstorage', 'onunload'].forEach(function (name) {\n      defineSetter(proto, name, function (handler) {\n        this._ownerDocument.parentWindow[name] = handler;\n      });\n      defineGetter(proto, name, function () {\n        return this._ownerDocument.parentWindow[name];\n      });\n    });\n    return proto;\n  })(),\n  tagName: 'BODY',\n  attributes: [\n    'aLink',\n    'background',\n    'bgColor',\n    'link',\n    'text',\n    'vLink'\n  ]\n});\n\ndefine('HTMLSelectElement', {\n  tagName: 'SELECT',\n  proto: {\n    _formReset: function() {\n      this.options._toArray().forEach(function(option, i) {\n        option._selectedness = option.defaultSelected;\n        option._dirtyness = false;\n      });\n      this._askedForAReset();\n    },\n    _askedForAReset: function() {\n      if (this.hasAttribute('multiple')) {\n        return;\n      }\n\n      var options = this.options._toArray();\n      var selected = options.filter(function(option){\n        return option._selectedness;\n      });\n\n      // size = 1 is default if not multiple\n      if ((!this.size || this.size === 1) && !selected.length) {\n        // select the first option that is not disabled\n        for (var i = 0; i < options.length; ++i) {\n          var option = options[i];\n          var disabled = option.disabled;\n          if (option._parentNode &&\n              option._parentNode.nodeName.toUpperCase() === 'OPTGROUP' &&\n              option._parentNode.disabled) {\n            disabled = true;\n          }\n\n          if (!disabled) {\n            // (do not set dirty)\n            option._selectedness = true;\n            break;\n          }\n        }\n      } else if (selected.length >= 2) {\n        // select the last selected option\n        selected.forEach(function(option, index) {\n          option._selectedness = index === selected.length - 1;\n        });\n      }\n    },\n    _descendantAdded: function(parent, child) {\n      if (child.nodeType === core.Node.ELEMENT_NODE) {\n        this._askedForAReset();\n      }\n\n      core.HTMLElement.prototype._descendantAdded.apply(this, arguments);\n    },\n    _descendantRemoved: function(parent, child) {\n      if (child.nodeType === core.Node.ELEMENT_NODE) {\n        this._askedForAReset();\n      }\n\n      core.HTMLElement.prototype._descendantRemoved.apply(this, arguments);\n    },\n    _attrModified: function(name, value) {\n      if (name === 'multiple' || name === 'size') {\n        this._askedForAReset();\n      }\n      core.HTMLElement.prototype._attrModified.apply(this, arguments);\n    },\n    get options() {\n      return new core.HTMLOptionsCollection(this, core.mapper(this, function(n) {\n        return n.nodeName === 'OPTION';\n      }));\n    },\n\n    get length() {\n      return this.options.length;\n    },\n\n    get selectedIndex() {\n      return this.options._toArray().reduceRight(function(prev, option, i) {\n        return option.selected ? i : prev;\n      }, -1);\n    },\n\n    set selectedIndex(index) {\n      this.options._toArray().forEach(function(option, i) {\n        option.selected = i === index;\n      });\n    },\n\n    get value() {\n      var i = this.selectedIndex;\n      if (this.options.length && (i === -1)) {\n        i = 0;\n      }\n      if (i === -1) {\n        return '';\n      }\n      return this.options[i].value;\n    },\n\n    set value(val) {\n      var self = this;\n      this.options._toArray().forEach(function(option) {\n        if (option.value === val) {\n          option.selected = true;\n        } else {\n          if (!self.hasAttribute('multiple')) {\n            // Remove the selected bit from all other options in this group\n            // if the multiple attr is not present on the select\n            option.selected = false;\n          }\n        }\n      });\n    },\n\n    get form() {\n      return closest(this, 'FORM');\n    },\n\n    get type() {\n      return this.multiple ? 'select-multiple' : 'select-one';\n    },\n\n    add: function(opt, before) {\n      if (before) {\n        this.insertBefore(opt, before);\n      }\n      else {\n        this.appendChild(opt);\n      }\n    },\n\n    remove: function(index) {\n      var opts = this.options._toArray();\n      if (index >= 0 && index < opts.length) {\n        var el = opts[index];\n        el._parentNode.removeChild(el);\n      }\n    }\n\n  },\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    {prop: 'multiple', type: 'boolean'},\n    'name',\n    {prop: 'size', type: 'long'},\n    {prop: 'tabIndex', type: 'long'},\n  ]\n});\n\ndefine('HTMLOptGroupElement', {\n  tagName: 'OPTGROUP',\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'label'\n  ]\n});\n\ndefine('HTMLOptionElement', {\n  tagName: 'OPTION',\n  proto: {\n    // whenever selectedness is set to true, make sure all\n    // other options set selectedness to false\n    _selectedness: false,\n    _dirtyness: false,\n    _removeOtherSelectedness: function() {\n      //Remove the selectedness flag from all other options in this select\n      var select = this._selectNode;\n\n      if (select && !select.multiple) {\n        var o = select.options;\n        for (var i = 0; i < o.length; i++) {\n          if (o[i] !== this) {\n            o[i]._selectedness = false;\n          }\n        }\n      }\n    },\n    _askForAReset: function() {\n      var select = this._selectNode;\n      if (select) {\n        select._askedForAReset();\n      }\n    },\n    _attrModified: function(name, value) {\n      if (!this._dirtyness && name === 'selected') {\n        this._selectedness = this.defaultSelected;\n        if (this._selectedness) {\n          this._removeOtherSelectedness();\n        }\n        this._askForAReset();\n      }\n      core.HTMLElement.prototype._attrModified.apply(this, arguments);\n    },\n    get _selectNode() {\n      var select = this._parentNode;\n      if (!select) return null;\n      if (select.nodeName.toUpperCase() !== 'SELECT') {\n        select = select._parentNode;\n        if (!select) return null;\n        if (select.nodeName.toUpperCase() !== 'SELECT') return null;\n      }\n      return select;\n    },\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get defaultSelected() {\n      return this.getAttribute('selected') !== null;\n    },\n    set defaultSelected(s) {\n      if (s) this.setAttribute('selected', 'selected');\n      else this.removeAttribute('selected');\n    },\n    get text() {\n      return this.innerHTML;\n    },\n    get value() {\n      return (this.hasAttribute('value')) ? this.getAttribute('value') : this.innerHTML;\n    },\n    set value(val) {\n      this.setAttribute('value', val);\n    },\n    get index() {\n      return closest(this, 'SELECT').options._toArray().indexOf(this);\n    },\n    get selected() {\n      return this._selectedness;\n    },\n    set selected(s) {\n      this._dirtyness = true;\n      this._selectedness = !!s;\n      if (this._selectedness) {\n        this._removeOtherSelectedness();\n      }\n      this._askForAReset();\n    }\n  },\n  attributes: [\n    {prop: 'disabled', type: 'boolean'},\n    'label'\n  ]\n});\n\ndefine('HTMLInputElement', {\n  tagName: 'INPUT',\n  init: function() {\n    if (!this.type) {\n      this.type = 'text';\n    }\n  },\n  proto: {\n    _value: null,\n    _dirtyValue: false,\n    _checkedness: false,\n    _dirtyCheckedness: false,\n    _attrModified: function(name, value) {\n      if (!this._dirtyValue && name === 'value') {\n        this._value = this.defaultValue;\n      }\n      if (!this._dirtyCheckedness && name === 'checked') {\n        this._checkedness = this.defaultChecked;\n        if (this._checkedness) {\n          this._removeOtherRadioCheckedness();\n        }\n      }\n\n      if (name === 'name' || name === 'type') {\n        if (this._checkedness) {\n          this._removeOtherRadioCheckedness();\n        }\n      }\n\n      core.HTMLElement.prototype._attrModified.apply(this, arguments);\n    },\n    _formReset: function() {\n      this._value = this.defaultValue;\n      this._dirtyValue = false;\n      this._checkedness = this.defaultChecked;\n      this._dirtyCheckedness = false;\n      if (this._checkedness) {\n        this._removeOtherRadioCheckedness();\n      }\n    },\n    _changedFormOwner: function(newForm) {\n      if (this._checkedness) {\n        this._removeOtherRadioCheckedness();\n      }\n    },\n    _removeOtherRadioCheckedness: function() {\n      var root = this._radioButtonGroupRoot;\n      if (!root) {\n        return;\n      }\n\n      var name = this.name.toLowerCase();\n      var radios = new core.HTMLCollection(this, core.mapper(root, function(el) {\n        return el.type === 'radio' &&\n               el.name &&\n               el.name.toLowerCase() === name &&\n               el._radioButtonGroupRoot === root;\n      }));\n\n      radios._toArray().forEach(function(radio) {\n        if (radio !== this) {\n          radio._checkedness = false;\n        }\n      }, this);\n    },\n    get _radioButtonGroupRoot() {\n      if (this.type !== 'radio' || !this.name) {\n        return null;\n      }\n\n      var e = this._parentNode;\n      while (e) {\n        // root node of this home sub tree\n        // or the form element we belong to\n        if (!e._parentNode || e.nodeName.toUpperCase() === 'FORM') {\n          return e;\n        }\n        e = e._parentNode;\n      }\n      return null;\n    },\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get defaultValue() {\n      var val = this.getAttribute('value');\n      return val !== null ? val : \"\";\n    },\n    set defaultValue(val) {\n      this.setAttribute('value', String(val));\n    },\n    get defaultChecked() {\n      return this.getAttribute('checked') !== null;\n    },\n    set defaultChecked(s) {\n      if (s) this.setAttribute('checked', 'checked');\n      else this.removeAttribute('checked');\n    },\n    get checked() {\n      return this._checkedness;\n    },\n    set checked(checked) {\n      this._checkedness = !!checked;\n      this._dirtyCheckedness = true;\n      if (this._checkedness) {\n        this._removeOtherRadioCheckedness();\n      }\n    },\n    get value() {\n      if (this._value === null) {\n        return '';\n      }\n      return this._value;\n    },\n    set value(val) {\n      this._dirtyValue = true;\n      if (val === null) {\n        this._value = null;\n      } else {\n        this._value = String(val);\n      }\n    },\n    get type() {\n        var type = this.getAttribute('type');\n        return type ? type : 'text';\n    },\n    set type(type) {\n        this.setAttribute('type', type);\n    },\n    select: function() {\n    },\n\n    _dispatchClickEvent: function() {\n      var event = this._ownerDocument.createEvent(\"HTMLEvents\");\n      event.initEvent(\"click\", true, true);\n      this.dispatchEvent(event);\n    },\n\n    click: function() {\n      if (this.type === 'checkbox') {\n        this.checked = !this.checked;\n      }\n      else if (this.type === 'radio') {\n        this.checked = true;\n      }\n      else if (this.type === 'submit') {\n        var form = this.form;\n        if (form) {\n          form._dispatchSubmitEvent();\n        }\n      }\n      this._dispatchClickEvent();\n    }\n  },\n  attributes: [\n    'accept',\n    'accessKey',\n    'align',\n    'alt',\n    {prop: 'disabled', type: 'boolean'},\n    {prop: 'maxLength', type: 'long'},\n    'name',\n    {prop: 'readOnly', type: 'boolean'},\n    {prop: 'size', type: 'long'},\n    'src',\n    {prop: 'tabIndex', type: 'long'},\n    {prop: 'type', normalize: function(val) {\n        return val ? val.toLowerCase() : 'text';\n    }},\n    'useMap'\n  ]\n});\n\ndefine('HTMLTextAreaElement', {\n  tagName: 'TEXTAREA',\n  proto: {\n    _apiValue: null,\n    _dirtyValue: false,\n    // \"raw value\" and \"value\" are not used here because jsdom has no GUI\n    _formReset: function() {\n      this._apiValue = null;\n      this._dirtyValue = false;\n    },\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get defaultValue() {\n      return this.textContent;\n    },\n    set defaultValue(val) {\n      this.textContent = val;\n    },\n    get value() {\n      // The WHATWG specifies that when \"textContent\" changes, the \"raw value\"\n      // (just the API value in jsdom) must also be updated.\n      // This slightly different solution has identical results, but is a lot less complex.\n      if (this._dirtyValue) {\n        if (this._apiValue === null) {\n          return '';\n        }\n        return this._apiValue;\n      }\n\n      var val = this.defaultValue;\n      val = val.replace(/\\r\\n|\\r/g, '\\n'); // API value normalizes line breaks per WHATWG\n      return val;\n    },\n    set value(val) {\n      if (val) {\n        val = val.replace(/\\r\\n|\\r/g, '\\n'); // API value normalizes line breaks per WHATWG\n      }\n\n      this._dirtyValue = true;\n      this._apiValue = val;\n    },\n    get textLength() {\n      return this.value.length; // code unit length (16 bit)\n    },\n    get type() {\n      return 'textarea';\n    },\n    select: function() {\n    }\n  },\n  attributes: [\n    'accessKey',\n    {prop: 'cols', type: 'long'},\n    {prop: 'disabled', type: 'boolean'},\n    {prop: 'maxLength', type: 'long'},\n    'name',\n    {prop: 'readOnly', type: 'boolean'},\n    {prop: 'rows', type: 'long'},\n    {prop: 'tabIndex', type: 'long'}\n  ]\n});\n\ndefine('HTMLButtonElement', {\n  tagName: 'BUTTON',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  },\n  attributes: [\n    'accessKey',\n    {prop: 'disabled', type: 'boolean'},\n    'name',\n    {prop: 'tabIndex', type: 'long'},\n    'type',\n    'value'\n  ]\n});\n\ndefine('HTMLLabelElement', {\n  tagName: 'LABEL',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  },\n  attributes: [\n    'accessKey',\n    {prop: 'htmlFor', attr: 'for'}\n  ]\n});\n\ndefine('HTMLFieldSetElement', {\n  tagName: 'FIELDSET',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  }\n});\n\ndefine('HTMLLegendElement', {\n  tagName: 'LEGEND',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    }\n  },\n  attributes: [\n    'accessKey',\n    'align'\n  ]\n});\n\ndefine('HTMLUListElement', {\n  tagName: 'UL',\n  attributes: [\n    {prop: 'compact', type: 'boolean'},\n    'type'\n  ]\n});\n\ndefine('HTMLOListElement', {\n  tagName: 'OL',\n  attributes: [\n    {prop: 'compact', type: 'boolean'},\n    {prop: 'start', type: 'long'},\n    'type'\n  ]\n});\n\ndefine('HTMLDListElement', {\n  tagName: 'DL',\n  attributes: [\n    {prop: 'compact', type: 'boolean'}\n  ]\n});\n\ndefine('HTMLDirectoryElement', {\n  tagName: 'DIR',\n  attributes: [\n    {prop: 'compact', type: 'boolean'}\n  ]\n});\n\ndefine('HTMLMenuElement', {\n  tagName: 'MENU',\n  attributes: [\n    {prop: 'compact', type: 'boolean'}\n  ]\n});\n\ndefine('HTMLLIElement', {\n  tagName: 'LI',\n  attributes: [\n    'type',\n    {prop: 'value', type: 'long'}\n  ]\n});\n\ndefine('HTMLCanvasElement', {\n  tagName: 'CANVAS',\n  attributes: [\n    'align'\n  ],\n  elementBuilder: function (element) {\n    // require node-canvas and catch the error if it blows up\n    try {\n      var canvas = new (require('canvas'))(0,0);\n      for (var attr in element) {\n        if (!canvas[attr]) {\n          canvas[attr] = element[attr];\n        }\n      }\n      return canvas;\n    } catch (e) {\n      return element;\n    }\n  }\n});\n\ndefine('HTMLDivElement', {\n  tagName: 'DIV',\n  attributes: [\n    'align'\n  ],\n  proto: {\n    toString: function() { return '[object HTMLDivElement]'; }\n  }\n});\n\ndefine('HTMLParagraphElement', {\n  tagName: 'P',\n  attributes: [\n    'align'\n  ]\n});\n\ndefine('HTMLHeadingElement', {\n  tagNames: ['H1','H2','H3','H4','H5','H6'],\n  attributes: [\n    'align'\n  ]\n});\n\ndefine('HTMLQuoteElement', {\n  tagNames: ['Q','BLOCKQUOTE'],\n  attributes: [\n    'cite'\n  ]\n});\n\ndefine('HTMLPreElement', {\n  tagName: 'PRE',\n  attributes: [\n    {prop: 'width', type: 'long'}\n  ]\n});\n\ndefine('HTMLBRElement', {\n  tagName: 'BR',\n  attributes: [\n    'clear'\n  ]\n});\n\ndefine('HTMLBaseFontElement', {\n  tagName: 'BASEFONT',\n  attributes: [\n    'color',\n    'face',\n    {prop: 'size', type: 'long'}\n  ]\n});\n\ndefine('HTMLFontElement', {\n  tagName: 'FONT',\n  attributes: [\n    'color',\n    'face',\n    'size'\n  ]\n});\n\ndefine('HTMLHRElement', {\n  tagName: 'HR',\n  attributes: [\n    'align',\n    {prop: 'noShade', type: 'boolean'},\n    'size',\n    'width'\n  ]\n});\n\ndefine('HTMLModElement', {\n  tagNames: ['INS', 'DEL'],\n  attributes: [\n    'cite',\n    'dateTime'\n  ]\n});\n\ndefine('HTMLAnchorElement', {\n  tagName: 'A',\n\n  proto: {\n    get href() {\n      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute('href'));\n    },\n    get hostname() {\n      return URL.parse(this.href).hostname || '';\n    },\n    get host() {\n      return URL.parse(this.href).host || '';\n    },\n    get origin() {\n      var proto = URL.parse(this.href).protocol;\n\n      if (proto !== undefined && proto !== null) {\n        proto += '//';\n      }\n\n      return proto + URL.parse(this.href).host || '';\n    },\n    get port() {\n      return URL.parse(this.href).port || '';\n    },\n    get protocol() {\n      var protocol = URL.parse(this.href).protocol;\n      return (protocol == null) ? ':' : protocol;\n    },\n    get password() {\n      var auth = URL.parse(this.href).auth;\n      return auth.substr(auth.indexOf(':') + 1);\n    },\n    get pathname() {\n      return URL.parse(this.href).pathname || '';\n    },\n    get username() {\n      var auth = URL.parse(this.href).auth;\n      return auth.substr(0, auth.indexOf(':'));\n    },\n    get search() {\n      return URL.parse(this.href).search || '';\n    },\n    get hash() {\n      return URL.parse(this.href).hash || '';\n    }\n  },\n  attributes: [\n    'accessKey',\n    'charset',\n    'coords',\n    {prop: 'href', type: 'string', read: false},\n    'hreflang',\n    'name',\n    'rel',\n    'rev',\n    'shape',\n    {prop: 'tabIndex', type: 'long'},\n    'target',\n    'type'\n  ]\n});\n\ndefine('HTMLImageElement', {\n  tagName: 'IMG',\n  proto: {\n    _attrModified: function(name, value, oldVal) {\n      if (name == 'src' && value !== oldVal) {\n        core.resourceLoader.enqueue(this, function() {})();\n      }\n    },\n    get src() {\n      return core.resourceLoader.resolve(this._ownerDocument, this.getAttribute('src'));\n    }\n  },\n  attributes: [\n    'name',\n    'align',\n    'alt',\n    'border',\n    {prop: 'height', type: 'long'},\n    {prop: 'hspace', type: 'long'},\n    {prop: 'isMap', type: 'boolean'},\n    'longDesc',\n    {prop: 'src', type: 'string', read: false},\n    'useMap',\n    {prop: 'vspace', type: 'long'},\n    {prop: 'width', type: 'long'}\n  ]\n});\n\ndefine('HTMLObjectElement', {\n  tagName: 'OBJECT',\n  proto: {\n    get form() {\n      return closest(this, 'FORM');\n    },\n    get contentDocument() {\n      return null;\n    }\n  },\n  attributes: [\n    'code',\n    'align',\n    'archive',\n    'border',\n    'codeBase',\n    'codeType',\n    'data',\n    {prop: 'declare', type: 'boolean'},\n    {prop: 'height',  type: 'long'},\n    {prop: 'hspace',  type: 'long'},\n    'name',\n    'standby',\n    {prop: 'tabIndex', type: 'long'},\n    'type',\n    'useMap',\n    {prop: 'vspace', type: 'long'},\n    {prop: 'width', type: 'long'}\n  ]\n});\n\ndefine('HTMLParamElement', {\n  tagName: 'PARAM',\n  attributes: [\n    'name',\n    'type',\n    'value',\n    'valueType'\n  ]\n});\n\ndefine('HTMLAppletElement', {\n  tagName: 'APPLET',\n  attributes: [\n    'align',\n    'alt',\n    'archive',\n    'code',\n    'codeBase',\n    'height',\n    {prop: 'hspace', type: 'long'},\n    'name',\n    'object',\n    {prop: 'vspace', type: 'long'},\n    'width'\n  ]\n});\n\ndefine('HTMLMapElement', {\n  tagName: 'MAP',\n  proto: {\n    get areas() {\n      return this.getElementsByTagName(\"AREA\");\n    }\n  },\n  attributes: [\n    'name'\n  ]\n});\n\ndefine('HTMLAreaElement', {\n  tagName: 'AREA',\n  attributes: [\n    'accessKey',\n    'alt',\n    'coords',\n    'href',\n    {prop: 'noHref', type: 'boolean'},\n    'shape',\n    {prop: 'tabIndex', type: 'long'},\n    'target'\n  ]\n});\n\ndefine('HTMLScriptElement', {\n  tagName: 'SCRIPT',\n  init: function() {\n    this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n      if (this.src) {\n        core.resourceLoader.load(this, this.src, this._eval);\n      }\n      else {\n        var src = this.sourceLocation || {},\n            filename = src.file || this._ownerDocument.URL;\n\n        if (src) {\n          filename += ':' + src.line + ':' + src.col;\n        }\n        filename += '<script>';\n\n        core.resourceLoader.enqueue(this, this._eval, filename)(null, this.text);\n      }\n    });\n  },\n  proto: {\n    _eval: function(text, filename) {\n      if (this._ownerDocument.implementation._hasFeature(\"ProcessExternalResources\", \"script\") &&\n          this.language                                                                      &&\n          core.languageProcessors[this.language])\n      {\n        this._ownerDocument._writeAfterElement = this;\n        core.languageProcessors[this.language](this, text, filename);\n        delete this._ownerDocument._writeAfterElement;\n      }\n    },\n    get language() {\n      var type = this.type || \"text/javascript\";\n      return type.split(\"/\").pop().toLowerCase();\n    },\n    get text() {\n      var i=0, children = this._childNodes, l = children.length, ret = [];\n\n      for (i; i<l; i++) {\n        ret.push(children[i].nodeValue);\n      }\n\n      return ret.join(\"\");\n    },\n    set text(text) {\n      while (this._childNodes.length) {\n        this.removeChild(this._childNodes[this._childNodes.length-1]);\n      }\n      this.appendChild(this._ownerDocument.createTextNode(text));\n    }\n  },\n  attributes : [\n    {prop: 'defer', 'type': 'boolean'},\n    'htmlFor',\n    'event',\n    'charset',\n    'type',\n    'src'\n  ]\n})\n\ndefine('HTMLTableElement', {\n  tagName: 'TABLE',\n  proto: {\n    get caption() {\n      return firstChild(this, 'CAPTION');\n    },\n    get tHead() {\n      return firstChild(this, 'THEAD');\n    },\n    get tFoot() {\n      return firstChild(this, 'TFOOT');\n    },\n    get rows() {\n      if (!this._rows) {\n        var table = this;\n        this._rows = new core.HTMLCollection(this._ownerDocument, function() {\n          var sections = [table.tHead].concat(table.tBodies._toArray(), table.tFoot).filter(function(s) { return !!s });\n\n          if (sections.length === 0) {\n            return core.mapDOMNodes(table, false, function(el) {\n              return el.tagName === 'TR';\n            });\n          }\n\n          return sections.reduce(function(prev, s) {\n            return prev.concat(s.rows._toArray());\n          }, []);\n\n        });\n      }\n      return this._rows;\n    },\n    get tBodies() {\n      if (!this._tBodies) {\n        this._tBodies = descendants(this, 'TBODY', false);\n      }\n      return this._tBodies;\n    },\n    createTHead: function() {\n      var el = this.tHead;\n      if (!el) {\n        el = this._ownerDocument.createElement('THEAD');\n        this.appendChild(el);\n      }\n      return el;\n    },\n    deleteTHead: function() {\n      var el = this.tHead;\n      if (el) {\n        el._parentNode.removeChild(el);\n      }\n    },\n    createTFoot: function() {\n      var el = this.tFoot;\n      if (!el) {\n        el = this._ownerDocument.createElement('TFOOT');\n        this.appendChild(el);\n      }\n      return el;\n    },\n    deleteTFoot: function() {\n      var el = this.tFoot;\n      if (el) {\n        el._parentNode.removeChild(el);\n      }\n    },\n    createCaption: function() {\n      var el = this.caption;\n      if (!el) {\n        el = this._ownerDocument.createElement('CAPTION');\n        this.appendChild(el);\n      }\n      return el;\n    },\n    deleteCaption: function() {\n      var c = this.caption;\n      if (c) {\n        c._parentNode.removeChild(c);\n      }\n    },\n    insertRow: function(index) {\n      var tr = this._ownerDocument.createElement('TR');\n      if (this._childNodes.length === 0) {\n        this.appendChild(this._ownerDocument.createElement('TBODY'));\n      }\n      var rows = this.rows._toArray();\n      if (index < -1 || index > rows.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      if (index === -1 || (index === 0 && rows.length === 0)) {\n        this.tBodies.item(0).appendChild(tr);\n      }\n      else if (index === rows.length) {\n        var ref = rows[index-1];\n        ref._parentNode.appendChild(tr);\n      }\n      else {\n        var ref = rows[index];\n        ref._parentNode.insertBefore(tr, ref);\n      }\n      return tr;\n    },\n    deleteRow: function(index) {\n      var rows = this.rows._toArray(), l = rows.length;\n      if (index === -1) {\n        index = l-1;\n      }\n      if (index < 0 || index >= l) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      var tr = rows[index];\n      tr._parentNode.removeChild(tr);\n    }\n  },\n  attributes: [\n    'align',\n    'bgColor',\n    'border',\n    'cellPadding',\n    'cellSpacing',\n    'frame',\n    'rules',\n    'summary',\n    'width'\n  ]\n});\n\ndefine('HTMLTableCaptionElement', {\n  tagName: 'CAPTION',\n  attributes: [\n    'align'\n  ]\n});\n\ndefine('HTMLTableColElement', {\n  tagNames: ['COL','COLGROUP'],\n  attributes: [\n    'align',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    {prop: 'span', type: 'long'},\n    'vAlign',\n    'width',\n  ]\n});\n\ndefine('HTMLTableSectionElement', {\n  tagNames: ['THEAD','TBODY','TFOOT'],\n  proto: {\n    get rows() {\n      if (!this._rows) {\n        this._rows = descendants(this, 'TR', false);\n      }\n      return this._rows;\n    },\n    insertRow: function(index) {\n      var tr = this._ownerDocument.createElement('TR');\n      var rows = this.rows._toArray();\n      if (index < -1 || index > rows.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      if (index === -1 || index === rows.length) {\n        this.appendChild(tr);\n      }\n      else {\n        var ref = rows[index];\n        this.insertBefore(tr, ref);\n      }\n      return tr;\n    },\n    deleteRow: function(index) {\n      var rows = this.rows._toArray();\n      if (index === -1) {\n        index = rows.length-1;\n      }\n      if (index < 0 || index >= rows.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      var tr = this.rows[index];\n      this.removeChild(tr);\n    }\n  },\n  attributes: [\n    'align',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    {prop: 'span', type: 'long'},\n    'vAlign',\n    'width',\n  ]\n});\n\ndefine('HTMLTableRowElement', {\n  tagName: 'TR',\n  proto: {\n    get cells() {\n      if (!this._cells) {\n        this._cells = new core.HTMLCollection(this, core.mapper(this, function(n) {\n          return n.nodeName === 'TD' || n.nodeName === 'TH';\n        }, false));\n      }\n      return this._cells;\n    },\n    get rowIndex() {\n      var table = closest(this, 'TABLE');\n      return table ? table.rows._toArray().indexOf(this) : -1;\n    },\n\n    get sectionRowIndex() {\n      return this._parentNode.rows._toArray().indexOf(this);\n    },\n    insertCell: function(index) {\n      var td = this._ownerDocument.createElement('TD');\n      var cells = this.cells._toArray();\n      if (index < -1 || index > cells.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      if (index === -1 || index === cells.length) {\n        this.appendChild(td);\n      }\n      else {\n        var ref = cells[index];\n        this.insertBefore(td, ref);\n      }\n      return td;\n    },\n    deleteCell: function(index) {\n      var cells = this.cells._toArray();\n      if (index === -1) {\n        index = cells.length-1;\n      }\n      if (index < 0 || index >= cells.length) {\n        throw new core.DOMException(core.INDEX_SIZE_ERR);\n      }\n      var td = this.cells[index];\n      this.removeChild(td);\n    }\n  },\n  attributes: [\n    'align',\n    'bgColor',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    'vAlign'\n  ]\n});\n\ndefine('HTMLTableCellElement', {\n  tagNames: ['TH','TD'],\n  proto: {\n    _headers: null,\n    set headers(h) {\n      if (h === '') {\n        //Handle resetting headers so the dynamic getter returns a query\n        this._headers = null;\n        return;\n      }\n      if (!(h instanceof Array)) {\n        h = [h];\n      }\n      this._headers = h;\n    },\n    get headers() {\n      if (this._headers) {\n        return this._headers.join(' ');\n      }\n      var cellIndex = this.cellIndex,\n          headings  = [],\n          siblings  = this._parentNode.getElementsByTagName(this.tagName);\n\n      for (var i=0; i<siblings.length; i++) {\n        if (siblings.item(i).cellIndex >= cellIndex) {\n          break;\n        }\n        headings.push(siblings.item(i).id);\n      }\n      this._headers = headings;\n      return headings.join(' ');\n    },\n    get cellIndex() {\n      return closest(this, 'TR').cells._toArray().indexOf(this);\n    }\n  },\n  attributes: [\n    'abbr',\n    'align',\n    'axis',\n    'bgColor',\n    {prop: 'ch', attr: 'char'},\n    {prop: 'chOff', attr: 'charoff'},\n    {prop: 'colSpan', type: 'long'},\n    'height',\n    {prop: 'noWrap', type: 'boolean'},\n    {prop: 'rowSpan', type: 'long'},\n    'scope',\n    'vAlign',\n    'width'\n  ]\n});\n\ndefine('HTMLFrameSetElement', {\n  tagName: 'FRAMESET',\n  attributes: [\n    'cols',\n    'rows'\n  ]\n});\n\nfunction loadFrame (frame) {\n  if (frame._contentDocument) {\n    // We don't want to access document.parentWindow, since the getter will\n    // cause a new window to be allocated if it doesn't exist.  Probe the\n    // private variable instead.\n    if (frame._contentDocument._parentWindow) {\n      // close calls delete on its document.\n      frame._contentDocument.parentWindow.close();\n    } else {\n      delete frame._contentDocument;\n    }\n  }\n\n  var src = frame.src.trim() === '' ? 'about:blank' : frame.src;\n  var parentDoc = frame._ownerDocument;\n\n  // If the URL can't be resolved or the src attribute is missing / blank,\n  // then url should be set to the string \"about:blank\".\n  // (http://www.whatwg.org/specs/web-apps/current-work/#the-iframe-element)\n  var url = core.resourceLoader.resolve(parentDoc, src);\n  var contentDoc = frame._contentDocument = new core.HTMLDocument({\n    parsingMode: 'html',\n    url: url,\n    documentRoot: Path.dirname(url)\n  });\n  applyDocumentFeatures(contentDoc, parentDoc.implementation._features);\n\n  var parent = parentDoc.parentWindow;\n  var contentWindow = contentDoc.parentWindow;\n  contentWindow.parent = parent;\n  contentWindow.top = parent.top;\n\n  // Handle about:blank with a simulated load of an empty document.\n  if(url === 'about:blank') {\n    core.resourceLoader.enqueue(frame, function() {\n      contentDoc.write();\n      contentDoc.close();\n    })();\n  } else {\n    core.resourceLoader.load(frame, url, function(html, filename) {\n      contentDoc.write(html);\n      contentDoc.close();\n    });\n  }\n}\n\ndefine('HTMLFrameElement', {\n  tagName: 'FRAME',\n  init : function () {\n    // Set up the frames array.  window.frames really just returns a reference\n    // to the window object, so the frames array is just implemented as indexes\n    // on the window.\n    var parent = this._ownerDocument.parentWindow;\n    var frameID = parent._length++;\n    var self = this;\n    defineGetter(parent, frameID, function () {\n      return self.contentWindow;\n    });\n\n    // The contentDocument/contentWindow shouldn't be created until the frame\n    // is inserted:\n    // \"When an iframe element is first inserted into a document, the user\n    //  agent must create a nested browsing context, and then process the\n    //  iframe attributes for the first time.\"\n    //  (http://www.whatwg.org/specs/web-apps/current-work/#the-iframe-element)\n    this._initInsertListener = function () {\n      loadFrame(self);\n    };\n    this.addEventListener('DOMNodeInsertedIntoDocument', this._initInsertListener, false);\n  },\n  proto: {\n    _attrModified: function(name, value, oldVal) {\n      core.HTMLElement.prototype._attrModified.call(this, name, value, oldVal);\n      var self = this;\n      if (name === 'name') {\n        // Remove named frame access.\n        if (oldVal) {\n          this._ownerDocument.parentWindow._frame(oldVal);\n        }\n        // Set up named frame access.\n        if (value) {\n          this._ownerDocument.parentWindow._frame(value, this);\n        }\n      } else if (name === 'src') {\n        // Page we don't fetch the page until the node is inserted. This at\n        // least seems to be the way Chrome does it.\n        if (!this._attachedToDocument) {\n          if (!this._waitingOnInsert) {\n            // First, remove the listener added in 'init'.\n            this.removeEventListener('DOMNodeInsertedIntoDocument',\n                                     this._initInsertListener, false)\n\n            // If we aren't already waiting on an insert, add a listener.\n            // This guards against src being set multiple times before the frame\n            // is inserted into the document - we don't want to register multiple\n            // callbacks.\n            this.addEventListener('DOMNodeInsertedIntoDocument', function loader () {\n              self.removeEventListener('DOMNodeInsertedIntoDocument', loader, false);\n              this._waitingOnInsert = false;\n              loadFrame(self);\n            }, false);\n            this._waitingOnInsert = true;\n          }\n        } else {\n          loadFrame(self);\n        }\n      }\n    },\n    _contentDocument : null,\n    get contentDocument() {\n      if (this._contentDocument == null) {\n        this._contentDocument = new core.HTMLDocument({ parsingMode: \"html\" });\n      }\n      return this._contentDocument;\n    },\n    get contentWindow() {\n      return this.contentDocument.parentWindow;\n    }\n  },\n  attributes: [\n    'frameBorder',\n    'longDesc',\n    'marginHeight',\n    'marginWidth',\n    'name',\n    {prop: 'noResize', type: 'boolean'},\n    'scrolling',\n    {prop: 'src', type: 'string', write: false}\n  ]\n});\n\ndefine('HTMLIFrameElement', {\n  tagName: 'IFRAME',\n  parentClass: core.HTMLFrameElement,\n  attributes: [\n    'align',\n    'frameBorder',\n    'height',\n    'longDesc',\n    'marginHeight',\n    'marginWidth',\n    'name',\n    'scrolling',\n    'src',\n    'width'\n  ]\n});\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level2/languages/javascript.js":"exports.javascript = function(element, code, filename) {\n  var doc = element.ownerDocument, window = doc && doc.parentWindow;\n  if (window) {\n    try {\n      window.run(code, filename);\n    } catch (e) {\n      element.raise(\n        'error', 'Running ' + filename + ' failed.',\n        {error: e, filename: filename}\n      );\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level2/style.js":"var core = require(\"../level1/core\"),\n    utils = require(\"../utils\"),\n    defineGetter = utils.defineGetter,\n    defineSetter = utils.defineSetter,\n    inheritFrom = utils.inheritFrom,\n    cssom = require(\"cssom\"),\n    cssstyle = require(\"cssstyle\"),\n    assert = require('assert');\n\n// What works now:\n// - Accessing the rules defined in individual stylesheets\n// - Modifications to style content attribute are reflected in style property\n// - Modifications to style property are reflected in style content attribute\n// TODO\n// - Modifications to style element's textContent are reflected in sheet property.\n// - Modifications to style element's sheet property are reflected in textContent.\n// - Modifications to link.href property are reflected in sheet property.\n// - Less-used features of link: disabled\n// - Less-used features of style: disabled, scoped, title\n// - CSSOM-View\n//   - getComputedStyle(): requires default stylesheet, cascading, inheritance,\n//     filtering by @media (screen? print?), layout for widths/heights\n// - Load events are not in the specs, but apparently some browsers\n//   implement something. Should onload only fire after all @imports have been\n//   loaded, or only the primary sheet?\n\ncore.StyleSheet = cssom.StyleSheet;\ncore.MediaList = cssom.MediaList;\ncore.CSSStyleSheet = cssom.CSSStyleSheet;\ncore.CSSRule = cssom.CSSRule;\ncore.CSSStyleRule = cssom.CSSStyleRule;\ncore.CSSMediaRule = cssom.CSSMediaRule;\ncore.CSSImportRule = cssom.CSSImportRule;\ncore.CSSStyleDeclaration = cssstyle.CSSStyleDeclaration;\n\n// Relavant specs\n// http://www.w3.org/TR/DOM-Level-2-Style (2000)\n// http://www.w3.org/TR/cssom-view/ (2008)\n// http://dev.w3.org/csswg/cssom/ (2010) Meant to replace DOM Level 2 Style\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/ HTML5, of course\n// http://dev.w3.org/csswg/css-style-attr/  not sure what's new here\n\n// Objects that aren't in cssom library but should be:\n//   CSSRuleList  (cssom just uses array)\n//   CSSFontFaceRule\n//   CSSPageRule\n\n// These rules don't really make sense to implement, so CSSOM draft makes them\n// obsolete.\n//   CSSCharsetRule\n//   CSSUnknownRule\n\n// These objects are considered obsolete by CSSOM draft, although modern\n// browsers implement them.\n//   CSSValue\n//   CSSPrimitiveValue\n//   CSSValueList\n//   RGBColor\n//   Rect\n//   Counter\n\n// StyleSheetList -\n// http://www.w3.org/TR/DOM-Level-2-Style/stylesheets.html#StyleSheets-StyleSheetList\n// added a push method to help manage the length\ncore.StyleSheetList = function() {\n  this._length = 0;\n};\ncore.StyleSheetList.prototype = {\n  item: function (i) {\n    return this[i];\n  },\n  push: function (sheet) {\n    this[this._length] = sheet;\n    this._length++;\n  },\n  get length() {\n    return this._length;\n  }\n};\n\ndefineGetter(core.Document.prototype, 'styleSheets', function() {\n  if (!this._styleSheets) {\n    this._styleSheets = new core.StyleSheetList();\n  }\n  // TODO: each style and link element should register its sheet on creation\n  // and remove it on removal.\n  return this._styleSheets;\n});\n\n\n/**\n * @this {core.HTMLLinkElement|core.HTMLStyleElement}\n * @param {string} url\n * @param {cssom.CSSStyleSheet} sheet\n * @see http://dev.w3.org/csswg/cssom/#requirements-on-user-agents-implementing0\n */\nfunction fetchStylesheet(url, sheet) {\n  core.resourceLoader.load(this, url, function(data, filename) {\n    // TODO: abort if the content-type is not text/css, and the document is\n    // in strict mode\n    sheet.href = core.resourceLoader.resolve(this.ownerDocument, url);\n    evaluateStylesheet.call(this, data, sheet, url);\n  });\n}\n/**\n * @this {core.HTMLLinkElement|core.HTMLStyleElement}\n * @param {string} data\n * @param {cssom.CSSStyleSheet} sheet\n * @param {string} baseUrl\n */\nfunction evaluateStylesheet(data, sheet, baseUrl) {\n  // this is the element\n  var newStyleSheet = cssom.parse(data);\n  var spliceArgs = newStyleSheet.cssRules;\n  spliceArgs.unshift(0, sheet.cssRules.length);\n  Array.prototype.splice.apply(sheet.cssRules, spliceArgs);\n  scanForImportRules.call(this, sheet.cssRules, baseUrl);\n  this.ownerDocument.styleSheets.push(sheet);\n}\n/**\n * @this {core.HTMLLinkElement|core.HTMLStyleElement}\n * @param {cssom.CSSStyleSheet} sheet\n * @param {string} baseUrl\n */\nfunction scanForImportRules(cssRules, baseUrl) {\n  if (!cssRules) return;\n  for (var i = 0; i < cssRules.length; ++i) {\n    if (cssRules[i].cssRules) {\n      // @media rule: keep searching inside it.\n      scanForImportRules.call(this, cssRules[i].cssRules, baseUrl);\n    } else if (cssRules[i].href) {\n      // @import rule: fetch the resource and evaluate it.\n      // See http://dev.w3.org/csswg/cssom/#css-import-rule\n      //     If loading of the style sheet fails its cssRules list is simply\n      //     empty. I.e. an @import rule always has an associated style sheet.\n      fetchStylesheet.call(this, cssRules[i].href, this.sheet);\n    }\n  }\n}\n\n/**\n * @param {string} data\n * @param {cssstyle.CSSStyleDeclaration} style\n */\nfunction evaluateStyleAttribute(data) {\n  // this is the element.\n\n}\n\n/**\n * Subclass of core.Attr that reflects the current cssText.\n */\nfunction StyleAttr(node, value) {\n  this._node = node;\n  core.Attr.call(this, node.ownerDocument, 'style');\n  if (!this._node._ignoreValueOfStyleAttr) {\n    this.nodeValue = value;\n  }\n}\ninheritFrom(core.Attr, StyleAttr, {\n  get nodeValue() {\n    if (typeof this._node._style === 'string') {\n      return this._node._style;\n    } else {\n      return this._node.style.cssText;\n    }\n  },\n  set nodeValue(value) {\n    this._node._style = value;\n  }\n});\n\nvar $setNode_super = core.AttributeList.prototype.$setNode;\n/**\n * Overwrite core.AttrNodeMap#setNamedItem to create a StyleAttr instance\n * instead of a core.Attr if the name equals 'style'.\n */\ncore.AttributeList.prototype.$setNode = function(attr) {\n  if (attr.name == 'style') {\n    attr = new StyleAttr(this._parentNode, attr.nodeValue);\n  }\n  return $setNode_super.call(this, attr);\n};\n\n/**\n * Lazily create a CSSStyleDeclaration.\n */\ndefineGetter(core.HTMLElement.prototype, 'style', function() {\n  if (typeof this._style === 'string') {\n    // currently, cssom's parse doesn't really work if you pass in\n    // {state: 'name'}, so instead we just build a dummy sheet.\n    var styleSheet = cssom.parse('dummy{' + this._style + '}');\n    this._style = new cssstyle.CSSStyleDeclaration();\n    if (styleSheet.cssRules.length > 0 && styleSheet.cssRules[0].style) {\n      var newStyle = styleSheet.cssRules[0].style;\n      for (var i = 0; i < newStyle.length; ++i) {\n        var prop = newStyle[i];\n        this._style.setProperty(\n            prop,\n            newStyle.getPropertyValue(prop),\n            newStyle.getPropertyPriority(prop));\n      }\n    }\n  }\n  if (!this._style) {\n    this._style = new cssstyle.CSSStyleDeclaration();\n\n  }\n  if (!this.getAttributeNode('style')) {\n    // Tell the StyleAttr constructor to not overwrite this._style\n    this._ignoreValueOfStyleAttr = true;\n    this.setAttribute('style');\n    this._ignoreValueOfStyleAttr = false;\n  }\n  return this._style;\n});\n\nassert.equal(undefined, core.HTMLLinkElement._init);\ncore.HTMLLinkElement._init = function() {\n  this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n    if (!/(?:[ \\t\\n\\r\\f]|^)stylesheet(?:[ \\t\\n\\r\\f]|$)/i.test(this.rel)) {\n      // rel is a space-separated list of tokens, and the original rel types\n      // are case-insensitive.\n      return;\n    }\n    if (this.href) {\n      fetchStylesheet.call(this, this.href, this.sheet);\n    }\n  });\n  this.addEventListener('DOMNodeRemovedFromDocument', function() {\n  });\n};\n/**\n * @this {HTMLStyleElement|HTMLLinkElement}\n */\nvar getOrCreateSheet = function() {\n  if (!this._cssStyleSheet) {\n    this._cssStyleSheet = new cssom.CSSStyleSheet();\n  }\n  return this._cssStyleSheet;\n};\ndefineGetter(core.HTMLLinkElement.prototype, 'sheet', getOrCreateSheet);\n\nassert.equal(undefined, core.HTMLStyleElement._init);\ncore.HTMLStyleElement._init = function() {\n  //console.log('init style')\n  this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n    //console.log('style inserted')\n    //console.log('sheet: ', this.sheet);\n    if (this.type && this.type !== 'text/css') {\n      //console.log('bad type: ' + this.type)\n      return;\n    }\n    var content = '';\n    this._childNodes.forEach(function (child) {\n      if (child.nodeType === child.TEXT_NODE) { // text node\n        content += child.nodeValue;\n      }\n    });\n    evaluateStylesheet.call(this, content, this.sheet, this._ownerDocument.URL);\n  });\n};\ndefineGetter(core.HTMLStyleElement.prototype, 'sheet', getOrCreateSheet);\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level3/core.js":"var core          = require(\"../level1/core\"),\n    defineGetter  = require('../utils').defineGetter,\n    defineSetter  = require('../utils').defineSetter,\n    HtmlToDom     = require('../browser/htmltodom').HtmlToDom,\n    domToHtml     = require('../browser/domtohtml').domToHtml;\n\n/*\n  valuetype DOMString sequence<unsigned short>;\n  typedef   unsigned long long DOMTimeStamp;\n  typedef   any DOMUserData;\n  typedef   Object DOMObject;\n\n*/\n// ExceptionCode\ncore.VALIDATION_ERR                 = 16;\ncore.TYPE_MISMATCH_ERR              = 17;\n\n/*\n  // Introduced in DOM Level 3:\n  interface NameList {\n    DOMString          getName(in unsigned long index);\n    DOMString          getNamespaceURI(in unsigned long index);\n    readonly attribute unsigned long   length;\n    boolean            contains(in DOMString str);\n    boolean            containsNS(in DOMString namespaceURI,\n                                  in DOMString name);\n  };\n\n  // Introduced in DOM Level 3:\n  interface DOMImplementationList {\n    DOMImplementation  item(in unsigned long index);\n    readonly attribute unsigned long   length;\n  };\n\n  // Introduced in DOM Level 3:\n  interface DOMImplementationSource {\n    DOMImplementation  getDOMImplementation(in DOMString features);\n    DOMImplementationList getDOMImplementationList(in DOMString features);\n  };\n*/\n\n\ncore.DOMImplementation.prototype.getFeature = function(feature, version)  {\n\n};\n\n/*\n  interface Node {\n    // Modified in DOM Level 3:\n    Node               insertBefore(in Node newChild,\n                                    in Node refChild)\n                                        raises(DOMException);\n    // Modified in DOM Level 3:\n    Node               replaceChild(in Node newChild,\n                                    in Node oldChild)\n                                        raises(DOMException);\n    // Modified in DOM Level 3:\n    Node               removeChild(in Node oldChild)\n                                        raises(DOMException);\n    // Modified in DOM Level 3:\n    Node               appendChild(in Node newChild)\n                                        raises(DOMException);\n    boolean            hasChildNodes();\n    Node               cloneNode(in boolean deep);\n    // Modified in DOM Level 3:\n    void               normalize();\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       baseURI;\n*/\n\n// Compare Document Position\nvar DOCUMENT_POSITION_DISCONNECTED = core.Node.DOCUMENT_POSITION_DISCONNECTED =\n                                     core.Node.prototype.DOCUMENT_POSITION_DISCONNECTED = 0x01;\n\nvar DOCUMENT_POSITION_PRECEDING    = core.Node.DOCUMENT_POSITION_PRECEDING =\n                                     core.Node.prototype.DOCUMENT_POSITION_PRECEDING    = 0x02;\n\nvar DOCUMENT_POSITION_FOLLOWING    = core.Node.DOCUMENT_POSITION_FOLLOWING =\n                                     core.Node.prototype.DOCUMENT_POSITION_FOLLOWING    = 0x04;\n\nvar DOCUMENT_POSITION_CONTAINS     = core.Node.DOCUMENT_POSITION_CONTAINS =\n                                     core.Node.prototype.DOCUMENT_POSITION_CONTAINS     = 0x08;\n\nvar DOCUMENT_POSITION_CONTAINED_BY = core.Node.DOCUMENT_POSITION_CONTAINED_BY =\n                                     core.Node.prototype.DOCUMENT_POSITION_CONTAINED_BY = 0x10;\n\nvar DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = core.Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC =\n                                                core.Node.prototype.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\n\nvar DOCUMENT_TYPE_NODE = core.Node.prototype.DOCUMENT_TYPE_NODE;\n\ncore.Node.prototype.compareDocumentPosition = function compareDocumentPosition( otherNode ) {\n  if( !(otherNode instanceof core.Node) ) {\n    throw Error(\"Comparing position against non-Node values is not allowed\")\n  }\n  var thisOwner, otherOwner;\n\n  if( this.nodeType === this.DOCUMENT_NODE)\n    thisOwner = this\n  else\n    thisOwner = this.ownerDocument\n\n  if( otherNode.nodeType === this.DOCUMENT_NODE)\n    otherOwner = otherNode\n  else\n    otherOwner = otherNode.ownerDocument\n\n  if( this === otherNode ) return 0\n  if( this === otherNode.ownerDocument ) return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY\n  if( this.ownerDocument === otherNode ) return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS\n  if( thisOwner !== otherOwner ) return DOCUMENT_POSITION_DISCONNECTED\n\n  // Text nodes for attributes does not have a _parentNode. So we need to find them as attribute child.\n  if( this.nodeType === this.ATTRIBUTE_NODE && this._childNodes && this._childNodes.indexOf(otherNode) !== -1)\n    return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY\n\n  if( otherNode.nodeType === this.ATTRIBUTE_NODE && otherNode._childNodes && otherNode._childNodes.indexOf(this) !== -1)\n    return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS\n\n  var point = this\n  var parents = [ ]\n  var previous = null\n  while( point ) {\n    if( point == otherNode ) return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS\n    parents.push( point )\n    point = point._parentNode\n  }\n  point = otherNode\n  previous = null\n  while( point ) {\n    if( point == this ) return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY\n    var location_index = parents.indexOf( point )\n    if( location_index !== -1) {\n     var smallest_common_ancestor = parents[ location_index ]\n     var this_index = smallest_common_ancestor._childNodes.indexOf( parents[location_index - 1] )\n     var other_index = smallest_common_ancestor._childNodes.indexOf( previous )\n     if( this_index > other_index ) {\n           return DOCUMENT_POSITION_PRECEDING\n     }\n     else {\n       return DOCUMENT_POSITION_FOLLOWING\n     }\n    }\n    previous = point\n    point = point._parentNode\n  }\n  return DOCUMENT_POSITION_DISCONNECTED\n};\n\n// @see http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-textContent\ndefineGetter(core.Node.prototype, 'textContent', function() {\n  switch (this.nodeType) {\n    case this.COMMENT_NODE:\n    case this.CDATA_SECTION_NODE:\n    case this.PROCESSING_INSTRUCTION_NODE:\n    case this.TEXT_NODE:\n      return this.nodeValue;\n\n    case this.ATTRIBUTE_NODE:\n    case this.DOCUMENT_FRAGMENT_NODE:\n    case this.ELEMENT_NODE:\n      var out = '';\n      for (var i = 0 ; i < this._childNodes.length ; ++i) {\n        if (this._childNodes[i].nodeType !== this.COMMENT_NODE &&\n            this._childNodes[i].nodeType !== this.PROCESSING_INSTRUCTION_NODE) {\n          out += this._childNodes[i].textContent || '';\n        }\n      }\n      return out;\n\n    default:\n      return null;\n  }\n});\n\ndefineSetter(core.Node.prototype, 'textContent', function(txt) {\n  switch (this.nodeType) {\n    case this.COMMENT_NODE:\n    case this.CDATA_SECTION_NODE:\n    case this.PROCESSING_INSTRUCTION_NODE:\n    case this.TEXT_NODE:\n      return this.nodeValue = String(txt);\n  }\n\n  for (var i = this._childNodes.length; --i >=0;) {\n    this.removeChild(this._childNodes[i]);\n  }\n  if (txt !== \"\" && txt != null) {\n    this.appendChild(this._ownerDocument.createTextNode(txt));\n  }\n  return txt;\n});\n\n/*\n    // Introduced in DOM Level 3:\n    DOMString          lookupPrefix(in DOMString namespaceURI);\n    // Introduced in DOM Level 3:\n    boolean            isDefaultNamespace(in DOMString namespaceURI);\n    // Introduced in DOM Level 3:\n    DOMString          lookupNamespaceURI(in DOMString prefix);\n    // Introduced in DOM Level 3:\n    DOMObject          getFeature(in DOMString feature,\n                                  in DOMString version);\n*/\n// Introduced in DOM Level 3:\ncore.Node.prototype.setUserData = function(key, data, handler) {\n  var r = this[key] || null;\n  this[key] = data;\n  return(r);\n};\n\n// Introduced in DOM Level 3:\ncore.Node.prototype.getUserData = function(key) {\n  var r = this[key] || null;\n  return(r);\n};\n/*\n  interface NodeList {\n    Node               item(in unsigned long index);\n    readonly attribute unsigned long   length;\n  };\n\n  interface NamedNodeMap {\n    Node               getNamedItem(in DOMString name);\n    Node               setNamedItem(in Node arg)\n                                        raises(DOMException);\n    Node               removeNamedItem(in DOMString name)\n                                        raises(DOMException);\n    Node               item(in unsigned long index);\n    readonly attribute unsigned long   length;\n    // Introduced in DOM Level 2:\n    Node               getNamedItemNS(in DOMString namespaceURI,\n                                      in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Node               setNamedItemNS(in Node arg)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Node               removeNamedItemNS(in DOMString namespaceURI,\n                                         in DOMString localName)\n                                        raises(DOMException);\n  };\n\n  interface CharacterData : Node {\n             attribute DOMString       data;\n                                        // raises(DOMException) on setting\n                                        // raises(DOMException) on retrieval\n\n    readonly attribute unsigned long   length;\n    DOMString          substringData(in unsigned long offset,\n                                     in unsigned long count)\n                                        raises(DOMException);\n    void               appendData(in DOMString arg)\n                                        raises(DOMException);\n    void               insertData(in unsigned long offset,\n                                  in DOMString arg)\n                                        raises(DOMException);\n    void               deleteData(in unsigned long offset,\n                                  in unsigned long count)\n                                        raises(DOMException);\n    void               replaceData(in unsigned long offset,\n                                   in unsigned long count,\n                                   in DOMString arg)\n                                        raises(DOMException);\n  };\n\n  interface Attr : Node {\n    readonly attribute DOMString       name;\n    readonly attribute boolean         specified;\n             attribute DOMString       value;\n                                        // raises(DOMException) on setting\n\n    // Introduced in DOM Level 2:\n    readonly attribute Element         ownerElement;\n    // Introduced in DOM Level 3:\n    readonly attribute TypeInfo        schemaTypeInfo;\n\n*/\n    // Introduced in DOM Level 3:\ndefineGetter(core.Attr.prototype, 'isId', function() {\n  return (this.name.toLowerCase() === 'id');\n});\n/*\n  };\n\n  interface Element : Node {\n    readonly attribute DOMString       tagName;\n    DOMString          getAttribute(in DOMString name);\n    void               setAttribute(in DOMString name,\n                                    in DOMString value)\n                                        raises(DOMException);\n    void               removeAttribute(in DOMString name)\n                                        raises(DOMException);\n    Attr               getAttributeNode(in DOMString name);\n    Attr               setAttributeNode(in Attr newAttr)\n                                        raises(DOMException);\n    Attr               removeAttributeNode(in Attr oldAttr)\n                                        raises(DOMException);\n    NodeList           getElementsByTagName(in DOMString name);\n    // Introduced in DOM Level 2:\n    DOMString          getAttributeNS(in DOMString namespaceURI,\n                                      in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    void               setAttributeNS(in DOMString namespaceURI,\n                                      in DOMString qualifiedName,\n                                      in DOMString value)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    void               removeAttributeNS(in DOMString namespaceURI,\n                                         in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Attr               getAttributeNodeNS(in DOMString namespaceURI,\n                                          in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Attr               setAttributeNodeNS(in Attr newAttr)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    NodeList           getElementsByTagNameNS(in DOMString namespaceURI,\n                                              in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    boolean            hasAttribute(in DOMString name);\n    // Introduced in DOM Level 2:\n    boolean            hasAttributeNS(in DOMString namespaceURI,\n                                      in DOMString localName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    readonly attribute TypeInfo        schemaTypeInfo;\n    // Introduced in DOM Level 3:\n    void               setIdAttribute(in DOMString name,\n                                      in boolean isId)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    void               setIdAttributeNS(in DOMString namespaceURI,\n                                        in DOMString localName,\n                                        in boolean isId)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    void               setIdAttributeNode(in Attr idAttr,\n                                          in boolean isId)\n                                        raises(DOMException);\n  };\n\n  interface Text : CharacterData {\n    Text               splitText(in unsigned long offset)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    readonly attribute boolean         isElementContentWhitespace;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       wholeText;\n    // Introduced in DOM Level 3:\n    Text               replaceWholeText(in DOMString content)\n                                        raises(DOMException);\n  };\n\n  interface Comment : CharacterData {\n  };\n\n  // Introduced in DOM Level 3:\n  interface TypeInfo {\n    readonly attribute DOMString       typeName;\n    readonly attribute DOMString       typeNamespace;\n\n    // DerivationMethods\n    const unsigned long       DERIVATION_RESTRICTION         = 0x00000001;\n    const unsigned long       DERIVATION_EXTENSION           = 0x00000002;\n    const unsigned long       DERIVATION_UNION               = 0x00000004;\n    const unsigned long       DERIVATION_LIST                = 0x00000008;\n\n    boolean            isDerivedFrom(in DOMString typeNamespaceArg,\n                                     in DOMString typeNameArg,\n                                     in unsigned long derivationMethod);\n  };\n*/\n// Introduced in DOM Level 3:\ncore.UserDataHandler = function() {};\ncore.UserDataHandler.prototype.NODE_CLONED   = 1;\ncore.UserDataHandler.prototype.NODE_IMPORTED = 2;\ncore.UserDataHandler.prototype.NODE_DELETED  = 3;\ncore.UserDataHandler.prototype.NODE_RENAMED  = 4;\ncore.UserDataHandler.prototype.NODE_ADOPTED  = 5;\ncore.UserDataHandler.prototype.handle = function(operation, key, data, src, dst) {};\n\n// Introduced in DOM Level 3:\ncore.DOMError = function(severity, message, type, relatedException, relatedData, location) {\n  this._severity         = severity;\n  this._message          = message;\n  this._type             = type;\n  this._relatedException = relatedException;\n  this._relatedData      = relatedData;\n  this._location         = location;\n};\ncore.DOMError.prototype = {};\ncore.DOMError.prototype.SEVERITY_WARNING     = 1;\ncore.DOMError.prototype.SEVERITY_ERROR       = 2;\ncore.DOMError.prototype.SEVERITY_FATAL_ERROR = 3;\ndefineGetter(core.DOMError.prototype, 'severity', function() {\n  return this._severity;\n});\ndefineGetter(core.DOMError.prototype, 'message', function() {\n  return this._message;\n});\ndefineGetter(core.DOMError.prototype, 'type', function() {\n  return this._type;\n});\ndefineGetter(core.DOMError.prototype, 'relatedException', function() {\n  return this._relatedException;\n});\ndefineGetter(core.DOMError.prototype, 'relatedData', function() {\n  return this._relatedData;\n});\ndefineGetter(core.DOMError.prototype, 'location', function() {\n  return this._location;\n});\n\n/*\n  // Introduced in DOM Level 3:\n  interface DOMErrorHandler {\n    boolean            handleError(in DOMError error);\n  };\n\n  // Introduced in DOM Level 3:\n  interface DOMLocator {\n    readonly attribute long            lineNumber;\n    readonly attribute long            columnNumber;\n    readonly attribute long            byteOffset;\n    readonly attribute long            utf16Offset;\n    readonly attribute Node            relatedNode;\n    readonly attribute DOMString       uri;\n  };\n*/\n\n// Introduced in DOM Level 3:\ncore.DOMConfiguration = function(){\n  var possibleParameterNames = {\n    'canonical-form': [false, true], // extra rules for true\n    'cdata-sections': [true, false],\n    'check-character-normalization': [false, true],\n    'comments': [true, false],\n    'datatype-normalization': [false, true],\n    'element-content-whitespace': [true, false],\n    'entities': [true, false],\n    // 'error-handler': [],\n    'infoset': [undefined, true, false], // extra rules for true\n    'namespaces': [true, false],\n    'namespace-declarations': [true, false], // only checked if namespaces is true\n    'normalize-characters': [false, true],\n    // 'schema-location': [],\n    // 'schema-type': [],\n    'split-cdata-sections': [true, false],\n    'validate': [false, true],\n    'validate-if-schema': [false, true],\n    'well-formed': [true, false]\n  }\n};\n\ncore.DOMConfiguration.prototype = {\n  setParameter: function(name, value) {},\n  getParameter: function(name) {},\n  canSetParameter: function(name, value) {},\n  parameterNames: function() {}\n};\n\n//core.Document.prototype._domConfig = new core.DOMConfiguration();\ndefineGetter(core.Document.prototype, 'domConfig', function() {\n  return this._domConfig || new core.DOMConfiguration();;\n});\n\n// Introduced in DOM Level 3:\ncore.DOMStringList = function() {};\n\ncore.DOMStringList.prototype = {\n  item: function() {},\n  length: function() {},\n  contains: function() {}\n};\n\n\n/*\n  interface CDATASection : Text {\n  };\n\n  interface DocumentType : Node {\n    readonly attribute DOMString       name;\n    readonly attribute NamedNodeMap    entities;\n    readonly attribute NamedNodeMap    notations;\n    // Introduced in DOM Level 2:\n    readonly attribute DOMString       publicId;\n    // Introduced in DOM Level 2:\n    readonly attribute DOMString       systemId;\n    // Introduced in DOM Level 2:\n    readonly attribute DOMString       internalSubset;\n  };\n\n  interface Notation : Node {\n    readonly attribute DOMString       publicId;\n    readonly attribute DOMString       systemId;\n  };\n\n  interface Entity : Node {\n    readonly attribute DOMString       publicId;\n    readonly attribute DOMString       systemId;\n    readonly attribute DOMString       notationName;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       inputEncoding;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       xmlEncoding;\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       xmlVersion;\n  };\n\n  interface EntityReference : Node {\n  };\n\n  interface ProcessingInstruction : Node {\n    readonly attribute DOMString       target;\n             attribute DOMString       data;\n                                        // raises(DOMException) on setting\n\n  };\n\n  interface DocumentFragment : Node {\n  };\n\n  interface Document : Node {\n    // Modified in DOM Level 3:\n    readonly attribute DocumentType    doctype;\n    readonly attribute DOMImplementation implementation;\n    readonly attribute Element         documentElement;\n    Element            createElement(in DOMString tagName)\n                                        raises(DOMException);\n    DocumentFragment   createDocumentFragment();\n    Text               createTextNode(in DOMString data);\n    Comment            createComment(in DOMString data);\n    CDATASection       createCDATASection(in DOMString data)\n                                        raises(DOMException);\n    ProcessingInstruction createProcessingInstruction(in DOMString target,\n                                                      in DOMString data)\n                                        raises(DOMException);\n    Attr               createAttribute(in DOMString name)\n                                        raises(DOMException);\n    EntityReference    createEntityReference(in DOMString name)\n                                        raises(DOMException);\n    NodeList           getElementsByTagName(in DOMString tagname);\n    // Introduced in DOM Level 2:\n    Node               importNode(in Node importedNode,\n                                  in boolean deep)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Element            createElementNS(in DOMString namespaceURI,\n                                       in DOMString qualifiedName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    Attr               createAttributeNS(in DOMString namespaceURI,\n                                         in DOMString qualifiedName)\n                                        raises(DOMException);\n    // Introduced in DOM Level 2:\n    NodeList           getElementsByTagNameNS(in DOMString namespaceURI,\n                                              in DOMString localName);\n    // Introduced in DOM Level 2:\n    Element            getElementById(in DOMString elementId);\n*/\n/*\n    // Introduced in DOM Level 3:\n    readonly attribute DOMString       xmlEncoding;\n    // Introduced in DOM Level 3:\n             attribute boolean         xmlStandalone;\n                                        // raises(DOMException) on setting\n\n    // Introduced in DOM Level 3:\n             attribute DOMString       xmlVersion;\n                                        // raises(DOMException) on setting\n\n    // Introduced in DOM Level 3:\n             attribute boolean         strictErrorChecking;\n    // Introduced in DOM Level 3:\n             attribute DOMString       documentURI;\n    // Introduced in DOM Level 3:\n    Node               adoptNode(in Node source)\n                                        raises(DOMException);\n    // Introduced in DOM Level 3:\n    readonly attribute DOMConfiguration domConfig;\n    // Introduced in DOM Level 3:\n    void               normalizeDocument();\n    // Introduced in DOM Level 3:\n    Node               renameNode(in Node n,\n                                  in DOMString namespaceURI,\n                                  in DOMString qualifiedName)\n                                        raises(DOMException);\n  };\n};\n\n#endif // _DOM_IDL_\n*/\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/htmltodom.js":"var parse5 = require('parse5');\nvar htmlparser2 = require('htmlparser2');\n\nfunction HtmlToDom(parser, parsingMode) {\n  if (!parser) {\n    if (parsingMode === \"xml\") {\n      parser = htmlparser2;\n    } else {\n      parser = parse5;\n    }\n  }\n\n  if (parser.DefaultHandler || (parser.Parser && parser.TreeAdapters)) {\n\n    // Forgiving HTML parser\n\n    if (parser.DefaultHandler){\n      // fb55/htmlparser2\n\n      parser.ParseHtml = function(rawHtml) {\n        var handler = new parser.DefaultHandler();\n        // Check if document is XML\n        var isXML = parsingMode === \"xml\";\n        var parserInstance = new parser.Parser(handler, {\n          xmlMode: isXML,\n          lowerCaseTags: !isXML,\n          lowerCaseAttributeNames: !isXML,\n          decodeEntities: true\n        });\n\n        parserInstance.includeLocation = false;\n        parserInstance.parseComplete(rawHtml);\n        return handler.dom;\n      };\n    } else if (parser.Parser && parser.TreeAdapters) {\n      parser.ParseHtml = function (rawHtml) {\n        if (parsingMode === 'xml') {\n          throw new Error('Can\\'t parse XML with parse5, please use htmlparser2 instead.');\n        }\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var dom = instance.parse(rawHtml);\n        return dom.children;\n      };\n    }\n\n    this.appendHtmlToElement = function(html, element) {\n\n      if (typeof html !== 'string') {\n        html +='';\n      }\n\n      var parsed = parser.ParseHtml(html);\n\n      for (var i = 0; i < parsed.length; i++) {\n        setChild(element, parsed[i]);\n      }\n\n      return element;\n    };\n    this.appendHtmlToDocument = this.appendHtmlToElement;\n\n    if (parser.Parser && parser.TreeAdapters) {\n      this.appendHtmlToElement = function (html, element) {\n\n        if (typeof html !== 'string') {\n          html += '';\n        }\n\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var parentElement = parser.TreeAdapters.htmlparser2.createElement(element.tagName.toLowerCase(), element.namespaceURI, []);\n        var dom = instance.parseFragment(html, parentElement);\n        var parsed = dom.children;\n\n        for (var i = 0; i < parsed.length; i++) {\n          setChild(element, parsed[i]);\n        }\n\n        return element;\n      };\n    }\n\n  } else if (parser.moduleName == 'HTML5') { /* HTML5 parser */\n    this.appendHtmlToElement = function(html, element) {\n\n      if (typeof html !== 'string') {\n        html += '';\n      }\n      if (html.length > 0) {\n        if (element.nodeType == 9) {\n          new parser.Parser({document: element}).parse(html);\n        }\n        else {\n          var p = new parser.Parser({document: element.ownerDocument});\n          p.parse_fragment(html, element);\n        }\n      }\n    };\n  } else {\n    this.appendHtmlToElement = function () {\n      console.log('');\n      console.log('###########################################################');\n      console.log('#  WARNING: No compatible HTML parser was given.');\n      console.log('#  Element.innerHTML setter support has been disabled');\n      console.log('#  Element.innerHTML getter support will still function');\n      console.log('###########################################################');\n      console.log('');\n    };\n  }\n};\n\n// utility function for forgiving parser\nfunction setChild(parent, node) {\n\n  var c, newNode, currentDocument = parent._ownerDocument || parent;\n\n  switch (node.type)\n  {\n    case 'tag':\n    case 'script':\n    case 'style':\n      try {\n        newNode = currentDocument._createElementNoTagNameValidation(node.name);\n        newNode._namespaceURI = node.namespace || \"http://www.w3.org/1999/xhtml\";\n        if (node.location) {\n          newNode.sourceLocation = node.location;\n          newNode.sourceLocation.file = parent.sourceLocation.file;\n        }\n      } catch (err) {\n        currentDocument.raise('error', 'invalid markup', {\n          exception: err,\n          node : node\n        });\n\n        return null;\n      }\n    break;\n\n    case 'root':\n        // If we are in <template> then implicitly create #document-fragment for it's content\n        if(parent.tagName === 'TEMPLATE' && parent._namespaceURI === 'http://www.w3.org/1999/xhtml') {\n            newNode = currentDocument.createDocumentFragment();\n            // Mark fragment as parser-created template content, so it will be accepted by appendChild()\n            newNode._templateContent = true;\n        }\n    break;\n\n    case 'text':\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n    break;\n\n    case 'comment':\n      newNode = currentDocument.createComment(node.data);\n    break;\n\n    case 'directive':\n      if (node.name[0] === '?' && node.name.toLowerCase() !== '?xml') {\n        var data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === '!doctype') {\n        newNode = parseDocType(currentDocument, '<' + node.data + '>');\n      }\n    break;\n\n    default:\n      return null;\n    break;\n  }\n\n  if (!newNode)\n    return null;\n\n  newNode._localName = node.name;\n\n  if (node.attribs) {\n    for (c in node.attribs) {\n      var prefix = node['x-attribsPrefix'] && node['x-attribsPrefix'][c] ? node['x-attribsPrefix'][c] + ':' : '';\n      // catchin errors here helps with improperly escaped attributes\n      // but properly fixing parent should (can only?) be done in the htmlparser itself\n      try {\n        newNode._setAttributeNoValidation(prefix + c, node.attribs[c]);\n        newNode.attributes[prefix + c]._namespaceURI = node['x-attribsNamespace'][c] || null;\n        newNode.attributes[prefix + c]._prefix = node['x-attribsPrefix'][c] || null;\n        newNode.attributes[prefix + c]._localName = c;\n      } catch(e2) { /* noop */ }\n    }\n  }\n\n  if (node.children) {\n    for (c = 0; c < node.children.length; c++) {\n      setChild(newNode, node.children[c]);\n    }\n  }\n\n  try{\n    return parent.appendChild(newNode);\n  }catch(err){\n    currentDocument.raise('error', err.message, {\n          exception: err,\n          node : node\n        });\n    return null;\n  }\n}\n\nvar HTML5_DOCTYPE = /<!doctype html>/i;\nvar PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nvar SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return doc.implementation.createDocumentType(\"html\", \"\", \"\");\n  }\n\n  var publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return doc.implementation.createDocumentType(publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  var systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return doc.implementation.createDocumentType(systemPieces[1], systemPieces[2], \"\");\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return doc.implementation.createDocumentType(\"html\", \"\", \"\");\n}\n\n\nexports.HtmlToDom = HtmlToDom;\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level3/ls.js":"// w3c Load/Save functionality: http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/\n\nvar core = require('../level1/core');\nvar createFrom = require('../utils').createFrom;\n\nvar ls = {};\n\n// TODO: what is this?\n//typedef dom::DOMConfiguration DOMConfiguration;\n\nls.LSException = function LSException(code) {\n  this.code = code;\n};\n\nls.LSException.prototype = {\n  // LSExceptionCode\n  PARSE_ERR                       : 81,\n  SERIALIZE_ERR                   : 82\n};\n\nls.DOMImplementationLS = function DOMImplementationLS() {\n\n};\n\nvar DOMImplementationExtension = {\n\n  // DOMImplementationLSMode\n  MODE_SYNCHRONOUS  : 1,\n  MODE_ASYNCHRONOUS : 2,\n\n  // raises(dom::DOMException);\n  createLSParser : function(/* int */ mode, /* string */ schemaType) {\n    return new ls.LSParser(mode, schemaType);\n  },\n\n  createLSSerializer : function() {\n    return new ls.LSSerializer();\n  },\n\n  createLSInput : function() {\n    return new ls.LSInput();\n  },\n\n  createLSOutput : function() {\n    return new ls.LSOutput();\n  }\n};\n\nObject.keys(DOMImplementationExtension).forEach(function(k, v) {\n  core.DOMImplementation.prototype[k] = DOMImplementationExtension[k];\n});\n\nls.DOMImplementationLS.prototype = DOMImplementationExtension;\n\ncore.Document.getFeature = function() {\n  return DOMImplementationExtension;\n};\n\nls.LSParser = function LSParser() {\n  this._domConfig = new core.DOMConfiguration();\n};\nls.LSParser.prototype = {\n  get domConfig() { return this._domConfig; },\n  get filter() { return this._filter || null; },\n  set filter(value) { this._filter = value; },\n  get async() { return this._async; },\n  get busy() { return this._busy; },\n\n  // raises(dom::DOMException, LSException);\n  parse : function (/* LSInput */ input) {\n    var doc = new core.Document();\n    doc._inputEncoding = 'UTF-16';\n    return doc;\n  },\n\n  // raises(dom::DOMException, LSException);\n  parseURI : function(/* string */ uri) {\n    return new core.Document();\n  },\n\n  // ACTION_TYPES\n  ACTION_APPEND_AS_CHILDREN       : 1,\n  ACTION_REPLACE_CHILDREN         : 2,\n  ACTION_INSERT_BEFORE            : 3,\n  ACTION_INSERT_AFTER             : 4,\n  ACTION_REPLACE                  : 5,\n\n  // @returns Node\n  // @raises DOMException, LSException\n  parseWithContext                : function(/* LSInput */ input, /* Node */ contextArg, /* int */ action) {\n    return new core.Node();\n  },\n\n  abort                           : function() {\n    // TODO: implement\n  }\n};\n\nls.LSInput = function LSInput() {};\nls.LSInput.prototype = {\n  get characterStream() { return this._characterStream || null; },\n  set characterStream(value) { this._characterStream = value; },\n  get byteStream() { return this._byteStream || null; },\n  set byteStream(value) { this._byteStream = value; },\n  get stringData() { return this._stringData || null; },\n  set stringData(value) { this._stringData = value; },\n  get systemId() { return this._systemId || null; },\n  set systemId(value) { this._systemId = value; },\n  get publicId() { return this._publicId || null; },\n  set publicId(value) { this._publicId = value; },\n  get baseURI() { return this._baseURI || null; },\n  set baseURI(value) { this._baseURI = value; },\n  get encoding() { return this._encoding || null; },\n  set encoding(value) { this._encoding = value; },\n  get certifiedText() { return this._certifiedText || null; },\n  set certifiedText(value) { this._certifiedText = value; },\n};\n\nls.LSResourceResolver = function LSResourceResolver() {};\n\n// @returns LSInput\nls.LSResourceResolver.prototype.resolveResource = function(type, namespaceURI, publicId, systemId, baseURI) {\n  return new ls.LSInput();\n};\n\nls.LSParserFilter = function LSParserFilter() {};\nls.LSParserFilter.prototype = {\n\n  // Constants returned by startElement and acceptNode\n  FILTER_ACCEPT                   : 1,\n  FILTER_REJECT                   : 2,\n  FILTER_SKIP                     : 3,\n  FILTER_INTERRUPT                : 4,\n\n  get whatToShow() { return this._whatToShow; },\n\n  // @returns int\n  startElement : function(/* Element */ elementArg) {\n    return 0;\n  },\n\n  // @returns int\n  acceptNode : function(/* Node */ nodeArg) {\n    return nodeArg;\n  }\n};\n\nls.LSSerializer = function LSSerializer() {\n  this._domConfig = new core.DOMConfiguration();\n};\nls.LSSerializer.prototype = {\n  get domConfig() { return this._domConfig; },\n  get newLine() { return this._newLine || null; },\n  set newLine(value) { this._newLine = value; },\n  get filter() { return this._filter || null; },\n  set filter(value) { this._filter = value; },\n\n  // @returns boolean\n  // @raises LSException\n  write : function(/* Node */ nodeArg, /* LSOutput */ destination) {\n   return true;\n  },\n\n  // @returns boolean\n  // @raises LSException\n  writeToURI : function(/* Node */ nodeArg, /* string */ uri) {\n   return true;\n  },\n\n  // @returns string\n  // @raises DOMException, LSException\n  writeToString : function(/* Node */ nodeArg) {\n    return \"\";\n  }\n};\n\nls.LSOutput = function LSOutput() {};\nls.LSOutput.prototype = {\n  get characterStream() { return this._characterStream || null; },\n  set characterStream(value) { this._characterStream = value; },\n  get byteStream() { return this._byteStream || null; },\n  set byteStream(value) { this._byteStream = value; },\n  get systemId() { return this._systemId || null; },\n  set systemId(value) { this._systemId = value; },\n  get encoding() { return this._encoding || null; },\n  set encoding(value) { this._encoding = value; },\n};\n\nls.LSProgressEvent = function LSProgressEvent() {};\nls.LSProgressEvent.prototype = createFrom(core.Event, {\n  constructor: ls.LSProgressEvent,\n  get input() { return this._input; },\n  get position() { return this._position; },\n  get totalSize() { return this._totalSize; },\n});\n\nls.LSLoadEvent = function LSLoadEvent() {};\nls.LSLoadEvent.prototype = createFrom(core.Event, {\n  get newDocument() { return this._newDocument; },\n  get input() { return this._input; },\n});\n\n\n// TODO: do traversal\nls.LSSerializerFilter = function LSSerializerFilter() {};\nls.LSSerializerFilter.prototype = {\n  get whatToShow() { return this._whatToShow; },\n};\n\n// ls.LSSerializerFilter.prototype.__proto__ = level2.traversal.NodeFiler;\n\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/level3/xpath.js":"/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\n(function() {\n  var xpath;\n  var core;\n  if ('function' === typeof require) {\n    xpath = exports; // the tests go through this\n    core = require(\"../level1/core\");\n  } else {\n    xpath = {};\n    core = this;\n  }\n\n\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null;\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n    this.prev = null;  // for debugging\n    this.prevprev = null;\n  }\n  Stream.prototype = {\n    peek: function() {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n    /** Peek 2 tokens ahead. */\n    peek2: function() {\n      this.peek();  // make sure this.peeked is set\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function() {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function(tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();;\n        }\n      }\n    },\n    trypopfuncname: function() {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok))\n        return null;\n      switch (tok) {\n        case 'comment': case 'text': case 'processing-instruction': case 'node':\n          return null;\n      }\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function() {\n      var tok = this.peek();\n      switch (tok) {\n        case 'ancestor': case 'ancestor-or-self': case 'attribute':\n        case 'child': case 'descendant': case 'descendant-or-self':\n        case 'following': case 'following-sibling': case 'namespace':\n        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n      return null;\n    },\n    trypopnametest: function() {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n      if ('\"' === first && '\"' === last ||\n          \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function() {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());\n      else return null;\n    },\n    trypopvarref: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);\n      else return null;\n    },\n    position: function() {\n      return this.original.length - this.str.length;\n    }\n  };\n  (function() {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon =\n        'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' +\n        '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' +\n        '\\uFDF0-\\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]\n    var nameCharExceptColon = nameStartCharsExceptColon +\n        '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon +\n        '][' + nameCharExceptColon + ']*'\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::';  // .. must come before [.]\n    var operatorChars =\n        'and|or|mod|div|' +\n        '//|!=|<=|>=|[*/|+\\\\-=<>]';  // //, !=, <=, >= before individual ones.\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*';  // stricter than regexp \\s.\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp(\n        // numberChars before otherChars so that leading-decimal doesn't become .\n        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +\n        nameTestChars + '|' + operatorChars + '|' + literal + '|' +\n        variableReference + ')'\n        // operatorName | nodeType | functionName | axisName are lumped into\n        // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream,a);\n    var x, unparsed = [];\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n    if (unparsed.length)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  }\n\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs;// TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) ||\n           relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n    var op;\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs,\n                     a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;\n      else isOnlyRootOk = false;\n      if (null == rhs)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep)  // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep)  // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName)\n        throw new XPathException(\n            XPathException.INVALID_EXPRESSION_ERR,\n            'Position ' + stream.position() +\n            ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';\n      else if ('namespace' === axis) nodeType = 'namespace';\n      else nodeType = 'element';\n    }\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n    if (null != type) {\n      if (null == stream.trypop('('))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen.');\n      var param = undefined;\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected close parens.');\n      return type\n    }\n  }\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;\n    else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected expression after [');\n    if (null == stream.trypop(']'))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x)\n      x = stream.trypopnumber();\n    if (null != x) {\n      return x;\n    }\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n    if (null != funCall) {\n      return funCall;\n    }\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression after (.');\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected ) after expression.');\n      return e;\n    }\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('('))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(','))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression as argument of function.');\n      params.push(param);\n    }\n    return a.node('FunctionCall', name, params);\n  }\n\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n      if (null == loc) {\n        throw new Error\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': The expression shouldn\\'t be empty...');\n      }\n      return a.node('PathExpr', loc);\n    }\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;\n    else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred, lhs = primary;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    }\n    else return unionExpr(stream, a);\n  }\n  var astFactory = {\n    node: function() {return Array.prototype.slice.call(arguments);}\n  };\n\n\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n  function optimize(ast) {\n  }\n\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = [];  // index within nodes that each series begins.\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function() {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + JSON.stringify(this.lasts));\n        }\n      }\n      this.pushSeries = this.popSeries = this.addNode = function() {\n        throw new Error('Already finalized.');\n      };\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n      this._pushToNodes.call(this.nodes, node)\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function() {\n      this.finalize();\n      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};\n    }\n  };\n  function eachContext(nodeMultiSet) {\n    var r = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n      if (!nodeMultiSet.pos) {\n        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});\n        }\n      }\n    }\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest =\n      null == nodeName ? this._alwaysTrue :\n      shouldLowerCase ? this._nodeNameLowerCaseEquals :\n      this._nodeNameEquals;\n  }\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      return (0 === this.nodeTypeNum || node.nodeType === this.nodeTypeNum) &&\n          this.nodeNameTest(node.nodeName);\n    },\n    _alwaysTrue: function(name) {return true;},\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n    while (0 < nodeList.length) {  // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n      while (null != node) {\n        if (! andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n        if (andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n      while (0 < numPushed--)\n        nodeMultiSet.popSeries();\n    }\n    return nodeMultiSet;\n  }\n\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild)\n        return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n    return null;\n  }\n\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n  function followingNode(node) {\n    if (node.ownerElement)  // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild)\n      return node.firstChild;\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n      node = node.parentNode;\n    } while (node);\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n  function precedingNode(node) {\n    if (node.ownerElement)\n      return node.ownerElement;\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n      return node;\n    }\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start)\n        unorderedFollowingStarts.push(start);\n    }\n    if (0 === unorderedFollowingStarts.length)\n      return {nodes:[]};\n    var pos = [], nextPos = [];\n    var started = 0;\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i,i+1);\n          started++;\n        }\n      }\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n    console.assert(0 === unorderedFollowingStarts.length);\n    for (var i = 0; i < started; i++)\n      nodeMultiSet.popSeries();\n    return nodeMultiSet.finalize();\n  }\n  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {nodes:{}};\n    var r = {nodes:[], pos:[], lasts:[]};\n    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n      var matches = matcher.matches(cursor);\n      var pos, someoneUsed = false;\n      if (matches)\n        pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j+1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n    return r;\n  }\n\n  /** node-set, axis -> node-set */\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n    if (null != node && !andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    var pushed = false;\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n    if (andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n    var nodeList = node.childNodes;\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [], attrNodes = [];\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n    nodeMultiSet.finalize();\n    for (var i = attrNodes.length-1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n    return nodeMultiSet;\n  }\n  /**\n   */\n  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node))\n            a.push(node);\n        }\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n      if (0 < a.length)\n        ancestors.push(a);\n    }\n    var lasts = [];\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {nodes:[], pos:[], lasts:[]};\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i+1);\n            lasts.splice(i, i+1);\n          }\n        }\n      }\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n  function addressVector(node) {\n    var r = [node];\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n    while (null != node) {\n      var i = 0;\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n      r.push(i);\n      node = node.parentNode\n    }\n    return r;\n  }\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node\n        alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c)\n        break;\n    }\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n    if (0 === c)\n      c = a.nodeName - b.nodeName;\n    if (0 === c)\n      c = 1;\n    return c;\n  }\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {\n    var a = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n    a.sort(addressComparator);\n    var b = [];\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0])\n        continue;\n      b.push(a[i][0]);\n    }\n    return b;\n  }\n  /** Sort node multiset. Does not do any de-duping. */\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({v:v, n:nodeMultiSet.nodes[i],\n              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});\n    }\n    a.sort(compare);\n    var r = {nodes:[], pos:[], lasts:[]};\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n    return ancestors;\n  }\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n    while (c = c.previousSibling) {\n      if (c === b)\n        return 1;  // b < a\n    }\n    c = b;\n    while (c = c.previousSibling) {\n      if (c === a)\n        return -1;  // a < b\n    }\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n  function mergeNodeLists(x, y) {\n    var a, b, aanc, banc, r = [];\n    if ('object' !== typeof x)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + x);\n    if ('object' !== typeof y)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + y);\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a)\n          aanc = addressVector(a);\n      }\n      if (null == b) {\n        b = y.shift();\n        if (null != b)\n          banc = addressVector(b);\n      }\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a.nodeName < b.nodeName) {  // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (a.nodeName > b.nodeName) {  // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c);\n        // just skip b without pushing it.\n        b = null;\n        banc = null;\n      }\n    }\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n    return r;\n  }\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison)\n      coersion = fn.number;\n    else coersion =\n      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :\n      'number' === typeof x || 'number' === typeof y ? fn.number :\n      fn.string;\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]});\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({nodes:[y.nodes[j]]});\n          if (test(xi, yj)) return true;\n        }\n      }\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);\n        if (test(xi, yc))\n          return true;\n      }\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);\n        if (test(xc, yi))\n          return true;\n      }\n      return false;\n    } else {\n      var xc = coersion(x), yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n  var axes = xpath.axes = {\n    'ancestor':\n      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'ancestor-or-self':\n      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'attribute':\n      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO: figure out whether positions should be undefined here.\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        if (null != nodeName) {\n          // TODO: with namespace\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null == node.getAttributeNode)\n              continue;  // only Element has .getAttributeNode\n            var attr = node.getAttributeNode(nodeName);\n            if (null != attr && matcher.matches(attr)) {\n              nodeMultiSet.pushSeries();\n              nodeMultiSet.addNode(attr);\n              nodeMultiSet.popSeries();\n            }\n          }\n        } else {\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null != node.attributes) {\n              nodeMultiSet.pushSeries();\n              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes\n                var attr = node.attributes[j];\n                if (matcher.matches(attr))  // TODO: I think this check is unnecessary\n                  nodeMultiSet.addNode(attr);\n              }\n              nodeMultiSet.popSeries();\n            }\n          }\n        }\n        return nodeMultiSet.finalize();\n      },\n    'child':\n      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        for (var i = 0; i < nodeList.length; ++i) {\n          var n = nodeList[i];\n          if (n.ownerElement)  // skip attribute nodes' text child.\n            continue;\n          if (n.childNodes) {\n            nodeMultiSet.pushSeries();\n            var childList = 1 === nodeTypeNum && null != n.children ?\n                n.children : n.childNodes;\n            for (var j = 0; j < childList.length; ++j) {\n              var child = childList[j];\n              if (matcher.matches(child)) {\n                nodeMultiSet.addNode(child);\n              }\n              // don't have to do de-duping because children have parent,\n              // which are current context.\n            }\n            nodeMultiSet.popSeries();\n          }\n        }\n        nodeMultiSet.finalize();\n        return sortNodeMultiSet(nodeMultiSet);\n      },\n    'descendant':\n      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'descendant-or-self':\n      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'following':\n      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'following-sibling':\n      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.shift, function() {return this[0];},\n          function(node) {return node.nextSibling;});\n      },\n    'namespace':\n      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO\n      },\n    'parent':\n      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodes = [], pos = [];\n        for (var i = 0; i < nodeList.length; ++i) {\n          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n          if (null == parent)\n            continue;\n          if (!matcher.matches(parent))\n            continue;\n          if (nodes.length > 0 && parent === nodes[nodes.length-1])\n            continue;\n          nodes.push(parent);\n          pos.push([1]);\n        }\n        return {nodes:nodes, pos:pos, lasts:pos};\n      },\n    'preceding':\n      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return precedingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'preceding-sibling':\n      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.pop, function() {return this[this.length-1];},\n          function(node) {return node.previousSibling},\n          false, true);\n      },\n    'self':\n      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var nodes = [], pos = [];\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        for (var i = 0; i < nodeList.length; ++i) {\n          if (matcher.matches(nodeList[i])) {\n            nodes.push(nodeList[i]);\n            pos.push([1]);\n          }\n        }\n        return {nodes: nodes, pos: pos, lasts: pos}\n      }\n  };\n\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject)\n        return optObject;\n      if ('string' === typeof optObject)\n        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n      if ('boolean' === typeof optObject)\n        return +optObject;\n      return fn.number(fn.string.call(this, optObject));  // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject)\n        return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject ||\n          'number' === typeof optObject)\n        return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent)\n        return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Function count(node-set) ' +\n                                 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {nodes: []};\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({nodes:[idNode]});\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length)\n          continue;\n        var node = doc.getElementById(id);\n        if (null != node)\n          r.nodes.push(node);\n      }\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      // TODO: namespaced version\n      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml\n    },\n    'namespace-uri': function(nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml\n    },\n    'concat': function concat(x) {\n      var l = [];\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Must be at least 2 arguments to string()');\n      }\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd);\n      // Note that xpath string positions user 1-based index\n      if (iEnd == null)\n        return sString.substr(iStart - 1);\n      else\n        return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n        eachCharRe.push(\n          c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\n            replace(/\\x08/g, '\\\\x08'));\n      }\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function(c) {return map[c];});\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() { return true; },\n    'false': function falseVal() { return false; },\n    // TODO\n    'lang': function lang(string) { throw new Error('Not implemented');},\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this);\n      // for node-sets, map id over each node value.\n      var sum = 0;\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({nodes:[node]});\n        sum += x;\n      }\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n  var more = {\n    UnaryMinus: function(x) { return -fn.number(x); },\n    '+': function(x, y) { return fn.number(x) + fn.number(y); },\n    '-': function(x, y) { return fn.number(x) - fn.number(y); },\n    '*': function(x, y) { return fn.number(x) * fn.number(y); },\n    'div': function(x, y) { return fn.number(x) / fn.number(y); },\n    'mod': function(x, y) { return fn.number(x) % fn.number(y); },\n    '<': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);\n    },\n    '<=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);\n    },\n    '>':  function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);\n    },\n    '>=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);\n    },\n    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },\n    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },\n    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },\n    '=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x === y;}, x, y);\n      }\n    },\n    '!=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (!aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x !== y;}, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8, // this.doc.COMMENT_NODE,\n    'text': 3, // this.doc.TEXT_NODE,\n    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1  //this.doc.ELEMENT_NODE\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function(x) {return helper(x);});\n      }\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx;\n    //  if (ctx.toString) return ctx.toString();\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n      for (var key in ctx) {\n        if (seenKey === key)\n          continue;\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n      delete ctx[seenKey];\n      return nicer;\n    }\n  }\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  }\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n      switch (ast[0]) {\n        case 'Root': return {nodes: [this.doc]};\n        case 'FunctionCall':\n          var functionName = ast[1], functionParams = ast[2];\n          if (null == fn[functionName])\n            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                     'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {nodes: []};\n          var contexts = eachContext(lhs);\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node);\n              // skip over all the rest of the same node.\n              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n          return ret;\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx);\n          // Make the nodeset a forward-direction-only one.\n          if (x.finalize) {  // it is a NodeMultiSet\n            for (var i = 0; i < x.nodes.length; ++i) {\n              console.assert(null != x.nodes[i].nodeType);\n            }\n            return {nodes: x.nodes};\n          } else {\n            return x;\n          }\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,  // TODO: give option\n              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {nodes:[], pos:[]};\n          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?\n          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {nodes: [context]});\n    return val;\n  }\n\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  }\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}\n  XPathEvaluator.prototype = {\n    createExpression: function(expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function(nodeResolver) {\n      // TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  }\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType)\n        throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(\n            core.WRONG_DOCUMENT_ERR,\n            'The document must be the same as the context node\\'s document.');\n      }\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {nodes: [contextNode]});\n      if (XPathResult.NUMBER_TYPE === type)\n        value = fn.number(value);\n      else if (XPathResult.STRING_TYPE === type)\n        value = fn.string(value);\n      else if (XPathResult.BOOLEAN_TYPE === type)\n        value = fn['boolean'](value);\n      else if (XPathResult.ANY_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&\n               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)\n        throw new core.DOMException(\n            core.NOT_SUPPORTED_ERR,\n            'You must provide an XPath result type (0=any).');\n      else if (XPathResult.ANY_TYPE !== type &&\n               'object' !== typeof value)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  }\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n    this._invalidated = false;\n    if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n        this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n      doc.addEventListener('DOMSubtreeModified', invalidate, true);\n      var self = this;\n      function invalidate() {\n        self._invalidated = true;\n        doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n      }\n    }\n  }\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n      switch (typeof this._value) {\n        case 'number': return XPathResult.NUMBER_TYPE;\n        case 'string': return XPathResult.STRING_TYPE;\n        case 'boolean': return XPathResult.BOOLEAN_TYPE;\n        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&\n          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        return false;\n      return !!this._invalidated;\n    },\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState)\n        throw new core.DOMException(\n            core.INVALID_STATE_ERR,\n            'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  };\n  // so you can access ANY_TYPE etc. from the instances:\n  XPathResult.prototype = Object.create(XPathResult,\n      Object.keys(proto).reduce(function (descriptors, name) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n        return descriptors;\n      }, {\n        constructor: {\n          value: XPathResult,\n          writable: true,\n          configurable: true\n        }\n      }));\n\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n\n  core.Document.prototype.createExpression =\n    XPathEvaluator.prototype.createExpression;\n\n  core.Document.prototype.createNSResolver =\n      XPathEvaluator.prototype.createNSResolver;\n\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/document-type.js":"\"use strict\";\nvar inheritFrom = require(\"../utils\").inheritFrom;\n\nmodule.exports = function (core) {\n  core.DocumentType = function DocumentType(ownerDocument, name, publicId, systemId) {\n    core.Node.call(this, ownerDocument);\n\n    this._name = name;\n    this._publicId = publicId;\n    this._systemId = systemId;\n  };\n\n  inheritFrom(core.Node, core.DocumentType, {\n    nodeType: core.Node.DOCUMENT_TYPE_NODE,  // TODO should be on prototype, not here\n    get name() { return this._name; },\n    get publicId() { return this._publicId; },\n    get systemId() { return this._systemId; }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/character-data.js":"\"use strict\";\nvar inheritFrom = require(\"../utils\").inheritFrom;\n\nmodule.exports = function (core) {\n  core.CharacterData = function CharacterData(ownerDocument, data) {\n    core.Node.call(this, ownerDocument);\n\n    this._data = data;\n  };\n\n  inheritFrom(core.Node, core.CharacterData, {\n    get data() { return this._data; },\n    set data(data) {\n      if (data === null) {\n        data = \"\";\n      }\n      data = String(data);\n\n      this._setData(data);\n    },\n\n    get length() {\n      return this._data.length;\n    },\n\n    substringData: function (offset, count) {\n      offset = offset >>> 0;\n      count = count >>> 0;\n\n      var length = this.length;\n\n      if (offset > length) {\n        throw new core.DOMException(core.DOMException.INDEX_SIZE_ERR);\n      }\n\n      if (offset + count > length) {\n        return this._data.substring(offset);\n      }\n\n      return this._data.substring(offset, offset + count);\n    },\n\n    appendData: function (data) {\n      this.replaceData(this.length, 0, data);\n    },\n\n    insertData: function (offset, data) {\n      this.replaceData(offset, 0, data);\n    },\n\n    deleteData: function (offset, count) {\n      this.replaceData(offset, count, \"\");\n    },\n\n    replaceData: function (offset, count, data) {\n      offset = offset >>> 0;\n      count = count >>> 0;\n      data = String(data);\n\n      var length = this.length;\n\n      if (offset > length) {\n        throw new core.DOMException(core.DOMException.INDEX_SIZE_ERR);\n      }\n\n      if (offset + count > length) {\n        count = length - offset;\n      }\n\n      var start = this._data.substring(0, offset);\n      var end = this._data.substring(offset + count);\n\n      this._setData(start + data + end);\n\n      // TODO: range stuff\n    },\n\n    _setData: function (newData) {\n      // TODO: remove this once we no longer rely on mutation events internally, since they are nonstandard\n      var oldData = this._data;\n      this._data = newData;\n\n      if (this._ownerDocument && this._parentNode && this._ownerDocument.implementation._hasFeature(\"MutationEvents\")) {\n        var ev = this._ownerDocument.createEvent(\"MutationEvents\");\n        ev.initMutationEvent(\"DOMCharacterDataModified\", true, false, this, oldData, newData, null, null);\n        this.dispatchEvent(ev);\n      }\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/processing-instruction.js":"\"use strict\";\nvar inheritFrom = require(\"../utils\").inheritFrom;\n\nmodule.exports = function (core) {\n  core.ProcessingInstruction = function ProcessingInstruction(ownerDocument, target, data) {\n    core.CharacterData.call(this, ownerDocument, data);\n\n    this._target = target;\n  };\n\n  inheritFrom(core.CharacterData, core.ProcessingInstruction, {\n    nodeType: core.Node.PROCESSING_INSTRUCTION_NODE, // TODO should be on prototype, not here\n    get target() { return this._target; }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/comment.js":"\"use strict\";\nvar inheritFrom = require(\"../utils\").inheritFrom;\n\nmodule.exports = function (core) {\n  // TODO: constructor should not take ownerDocument\n  core.Comment = function Comment(ownerDocument, data) {\n    core.CharacterData.call(this, ownerDocument, data);\n  };\n\n  inheritFrom(core.CharacterData, core.Comment, {\n    nodeType: core.Node.COMMENT_NODE, // TODO should be on prototype, not here\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/text.js":"\"use strict\";\nvar inheritFrom = require(\"../utils\").inheritFrom;\n\nmodule.exports = function (core) {\n  // TODO: constructor should not take ownerDocument\n  core.Text = function Text(ownerDocument, data) {\n    core.CharacterData.call(this, ownerDocument, data);\n  };\n\n  inheritFrom(core.CharacterData, core.Text, {\n    nodeType: core.Node.TEXT_NODE, // TODO should be on prototype, not here\n    splitText: function (offset) {\n      offset = offset >>> 0;\n\n      var length = this.length;\n\n      if (offset > length) {\n        throw new core.DOMException(core.DOMException.INDEX_SIZE_ERR);\n      }\n\n      var count = length - offset;\n      var newData = this.substringData(offset, count);\n\n      var newNode = this._ownerDocument.createTextNode(newData);\n\n      var parent = this._parentNode;\n\n      if (parent !== null) {\n        parent.insertBefore(newNode, this.nextSibling);\n      }\n\n      this.replaceData(offset, count, \"\");\n\n      return newNode;\n\n      // TODO: range stuff\n    },\n\n    // TODO: wholeText property\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/dom-implementation.js":"\"use strict\";\nvar validateNames = require(\"./helpers/validate-names\");\n\nmodule.exports = function (core) {\n  core.DOMImplementation.prototype.hasFeature = function () {\n    return true;\n  };\n\n  core.DOMImplementation.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {\n    qualifiedName = String(qualifiedName);\n    publicId = String(publicId);\n    systemId = String(systemId);\n\n    validateNames.qname(qualifiedName, core);\n\n    return new core.DocumentType(this._ownerDocument, qualifiedName, publicId, systemId);\n  };\n\n  core.DOMImplementation.prototype.createDocument = function (namespace, qualifiedName, doctype) {\n    namespace = namespace !== null ? String(namespace) : namespace;\n    qualifiedName = qualifiedName === null ? \"\" : String(qualifiedName);\n    if (doctype === undefined) {\n      doctype = null;\n    }\n\n    var document = new core.Document({ parsingMode: \"xml\" });\n\n    var element = null;\n    if (qualifiedName !== \"\") {\n      element = document.createElementNS(namespace, qualifiedName);\n    }\n\n    if (doctype !== null) {\n      document.appendChild(doctype);\n    }\n\n    if (element !== null) {\n      document.appendChild(element);\n    }\n\n    return document;\n  };\n\n  core.DOMImplementation.prototype.createHTMLDocument = function (title) {\n    // Let doc be a new document that is an HTML document.\n    // Set doc's content type to \"text/html\".\n    var document = new core.HTMLDocument({ parsingMode: \"html\" });\n\n    // Create a doctype, with \"html\" as its name and with its node document set\n    // to doc. Append the newly created node to doc.\n    var doctype = this.createDocumentType(\"html\", \"\", \"\");\n    document.appendChild(doctype);\n\n    // Create an html element in the HTML namespace, and append it to doc.\n    var htmlElement = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"html\");\n    document.appendChild(htmlElement);\n\n    // Create a head element in the HTML namespace, and append it to the html\n    // element created in the previous step.\n    var headElement = document.createElement(\"head\");\n    htmlElement.appendChild(headElement);\n\n    // If the title argument is not omitted:\n    if (title !== undefined) {\n      // Create a title element in the HTML namespace, and append it to the head\n      // element created in the previous step.\n      var titleElement = document.createElement(\"title\");\n      headElement.appendChild(titleElement);\n\n      // Create a Text node, set its data to title (which could be the empty\n      // string), and append it to the title element created in the previous step.\n      titleElement.appendChild(document.createTextNode(title));\n    }\n\n    // Create a body element in the HTML namespace, and append it to the html\n    // element created in the earlier step.\n    htmlElement.appendChild(document.createElement(\"body\"));\n\n    // doc's origin is an alias to the origin of the context object's associated\n    // document, and doc's effective script origin is an alias to the effective\n    // script origin of the context object's associated document.\n\n    return document;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/document.js":"\"use strict\";\nvar validateNames = require(\"./helpers/validate-names\");\n\nmodule.exports = function (core) {\n  core.Document.prototype.createProcessingInstruction = function (target, data) {\n    target = String(target);\n    data = String(data);\n\n    validateNames.name(target, core);\n\n    if (data.indexOf(\"?>\") !== -1) {\n      throw new core.DOMException(core.DOMException.INVALID_CHARACTER_ERR,\n        \"Processing instruction data cannot contain the string \\\"?>\\\"\");\n    }\n\n    return new core.ProcessingInstruction(this._ownerDocument, target, data);\n  };\n\n  core.Document.prototype.createTextNode = function (data) {\n    return new core.Text(this, String(data));\n  };\n\n  core.Document.prototype.createComment = function (data) {\n    return new core.Comment(this, String(data));\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/node-filter.js":"\"use strict\";\nvar addConstants = require(\"../utils\").addConstants;\n\nmodule.exports = function (core) {\n  // https://dom.spec.whatwg.org/#interface-nodefilter\n  core.NodeFilter = function () {\n    throw new TypeError(\"Illegal constructor\");\n  };\n\n  /**\n   * Returns an unsigned short that will be used to tell if a given Node must\n   * be accepted or not by the NodeIterator or TreeWalker iteration\n   * algorithm. This method is expected to be written by the user of a\n   * NodeFilter.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter\n   * @interface\n   *\n   * @param  {Node} node DOM Node\n   * @return {FILTER_ACCEPT|FILTER_REJECT|FILTER_SKIP}\n   */\n  core.NodeFilter.acceptNode = function(/* node */) {\n    throw new Error(\"This method is expected to be written by the user of a NodeFilter.\");\n  };\n\n  addConstants(core.NodeFilter, {\n    // Constants for whatToShow\n    SHOW_ALL                    : 0xFFFFFFFF,\n    SHOW_ELEMENT                : 0x00000001,\n    SHOW_ATTRIBUTE              : 0x00000002,\n    SHOW_TEXT                   : 0x00000004,\n    SHOW_CDATA_SECTION          : 0x00000008,\n    SHOW_ENTITY_REFERENCE       : 0x00000010,\n    SHOW_ENTITY                 : 0x00000020,\n    SHOW_PROCESSING_INSTRUCTION : 0x00000040,\n    SHOW_COMMENT                : 0x00000080,\n    SHOW_DOCUMENT               : 0x00000100,\n    SHOW_DOCUMENT_TYPE          : 0x00000200,\n    SHOW_DOCUMENT_FRAGMENT      : 0x00000400,\n    SHOW_NOTATION               : 0x00000800,\n\n    // Constants returned by acceptNode\n    FILTER_ACCEPT               : 1,\n    FILTER_REJECT               : 2,\n    FILTER_SKIP                 : 3\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/node.js":"\"use strict\";\nvar defineGetter = require(\"../utils\").defineGetter;\n\nmodule.exports = function (core) {\n  var DOCUMENT_POSITION_DISCONNECTED = core.Node.DOCUMENT_POSITION_DISCONNECTED;\n  var DOCUMENT_POSITION_PRECEDING = core.Node.DOCUMENT_POSITION_PRECEDING;\n  var DOCUMENT_POSITION_FOLLOWING = core.Node.DOCUMENT_POSITION_FOLLOWING;\n  var DOCUMENT_POSITION_CONTAINS = core.Node.DOCUMENT_POSITION_CONTAINS;\n  var DOCUMENT_POSITION_CONTAINED_BY = core.Node.DOCUMENT_POSITION_CONTAINED_BY;\n  var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = core.Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;\n\n  /**\n   * Return true if node is of a type obsoleted by the WHATWG living standard\n   * @param  {Node}  node\n   * @return {Boolean}\n   */\n  function isObsoleteNodeType(node) {\n    return node.nodeType === core.Node.ENTITY_NODE ||\n      node.nodeType === core.Node.ENTITY_REFERENCE_NODE ||\n      node.nodeType === core.Node.NOTATION_NODE ||\n      node.nodeType === core.Node.CDATA_SECTION_NODE;\n  }\n\n  /**\n   * Return the parent node of node, whatever its nodeType is\n   * @param  {Node} node\n   * @return {Node or null}\n   */\n  function getNodeParent(node) {\n\n    if(!node) {\n      return node;\n    }\n\n    switch (node.nodeType) {\n\n      case core.Node.DOCUMENT_NODE:\n      case core.Node.DOCUMENT_FRAGMENT_NODE:\n        return null;\n\n      case core.Node.COMMENT_NODE:\n      case core.Node.DOCUMENT_TYPE_NODE:\n      case core.Node.ELEMENT_NODE:\n      case core.Node.PROCESSING_INSTRUCTION_NODE:\n      case core.Node.TEXT_NODE:\n        return node.parentNode;\n\n      case core.Node.ATTRIBUTE_NODE:\n\n        return node._parentNode;\n\n      default:\n        throw new Error(\"Unknown node type:\" + node.nodeType);\n    }\n  }\n\n  /**\n   * Walk up the node tree and return the nodes root node\n   * @param  {Node} node\n   * @return {Node}\n   */\n  function findNodeRoot(node) {\n    if (!getNodeParent(node)) {\n      return node;\n    }\n\n    return findNodeRoot(getNodeParent(node));\n  }\n\n  /**\n   * Walk up the node tree returning true if otherNode is an ancestor of node\n   * @param  {Node}  node\n   * @param  {Node}  otherNode\n   * @return {Boolean}\n   */\n  function isAncestor(node, otherNode) {\n    var parentNode = node.nodeType === node.ATTRIBUTE_NODE ? node._parentNode : node.parentNode;\n\n    if (!parentNode) {\n      return false;\n    }\n\n    if(parentNode === otherNode) {\n      return true;\n    }\n\n    return isAncestor(parentNode, otherNode);\n  }\n\n  /**\n   * Traverse the node tree starting at current. Return DOCUMENT_POSITION_FOLLOWING if otherNode follows node. Return\n   * DOCUMENT_POSITION_PRECEDING if otherNode precedes node\n   * @param  {Node} current\n   * @param  {Node} node\n   * @param  {Node} otherNode\n   * @return {Number}\n   */\n  function followingOrPreceding(current, node, otherNode) {\n    if (current === node) {\n      return core.Node.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    if (current === otherNode) {\n      return core.Node.DOCUMENT_POSITION_PRECEDING;\n    }\n\n    var i = 0, len = current._childNodes.length, child, result;\n\n    for(; i < len; i += 1) {\n\n      child = current._childNodes[i];\n\n      if((result = followingOrPreceding(child, node, otherNode)) !== 0) {\n        return result;\n      }\n    }\n\n    return 0;\n  }\n\n  /**\n   * Returns a bitmask Number composed of DOCUMENT_POSITION constants based upon the rules defined in\n   * http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n   * @param  {Node} other\n   * @return {Number}\n   */\n  core.Node.prototype.compareDocumentPosition = function compareDocumentPosition (other) {\n    // Let reference be the context object.\n    var reference = this;\n\n    if(!(other instanceof core.Node)) {\n      throw Error(\"Comparing position against non-Node values is not allowed\");\n    }\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(other)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    // If other and reference are the same object, return zero.\n    if (reference === other) {\n      return 0;\n    }\n\n    // If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING,\n    // with the constraint that this is to be consistent, together.\n    if (findNodeRoot(reference) !== findNodeRoot(other)) {\n      return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    // If other is an ancestor of reference, return the result of adding DOCUMENT_POSITION_CONTAINS to\n    // DOCUMENT_POSITION_PRECEDING.\n    if (isAncestor(reference, other)) {\n      return DOCUMENT_POSITION_CONTAINS + DOCUMENT_POSITION_PRECEDING;\n    }\n\n    // If other is a descendant of reference, return the result of adding DOCUMENT_POSITION_CONTAINED_BY to\n    // DOCUMENT_POSITION_FOLLOWING.\n    if (isAncestor(other, reference)) {\n      return DOCUMENT_POSITION_CONTAINED_BY + DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    // If other is preceding reference return DOCUMENT_POSITION_PRECEDING, otherwise return DOCUMENT_POSITION_FOLLOWING\n    return followingOrPreceding(findNodeRoot(reference), reference, other);\n  };\n\n  /**\n   * The contains(other) method returns true if other is an inclusive descendant of the context object,\n   * and false otherwise (including when other is null).\n   * @param  {[Node]} other [the node to test]\n   * @return {[boolean]}      [whether other is an inclusive descendant of this]\n   */\n  core.Node.prototype.contains = function (other) {\n    return other instanceof core.Node &&\n    (this === other || this.compareDocumentPosition(other) & DOCUMENT_POSITION_CONTAINED_BY);\n  };\n\n  // http://dom.spec.whatwg.org/#dom-node-parentelement\n  defineGetter(core.Node.prototype, \"parentElement\", function () {\n    return this._parentNode !== null && this._parentNode.nodeType === core.Node.ELEMENT_NODE ? this._parentNode : null;\n  });\n\n  function nodeEquals(a, b) {\n    if (a.nodeType !== b.nodeType) {\n      return false;\n    }\n\n    switch (a.nodeType) {\n      case core.Node.DOCUMENT_TYPE_NODE:\n        if (a._name !== b._name || a._publicId !== b._publicId || a._systemId !== b._systemId) {\n          return false;\n        }\n        break;\n      case core.Node.ELEMENT_NODE:\n        if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n            a._attributes.length !== b._attributes.length) {\n          return false;\n        }\n        break;\n      case core.Node.PROCESSING_INSTRUCTION_NODE:\n        if (a._target !== b._target || a._data !== b._data) {\n          return false;\n        }\n        break;\n      case core.Node.TEXT_NODE:\n      case core.Node.COMMENT_NODE:\n        if (a._data !== b._data) {\n          return false;\n        }\n        break;\n    }\n\n    if (a.nodeType === core.Node.ELEMENT_NODE) {\n      for (var i = 0; i < a._attributes.length; ++i) {\n        var aAttr = a._attributes[i];\n        var bAttr = b._attributes.$getNode(aAttr._namespaceURI, aAttr._localName);\n        if (!bAttr) {\n          return false;\n        }\n\n        // TODO: once Attr is simplified, check the internal property instead of the public getter\n        if (aAttr.value !== bAttr.value) {\n          return false;\n        }\n      }\n    }\n\n    if (a._childNodes.length !== b._childNodes.length) {\n      return false;\n    }\n\n    for (var j = 0; j < a._childNodes.length; ++j) {\n      if (!nodeEquals(a._childNodes[j], b._childNodes[j])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-isequalnode\n  core.Node.prototype.isEqualNode = function (node) {\n    if (node === undefined) {\n      // this is what Node? means in the IDL\n      node = null;\n    }\n\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  };\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/living/selectors.js":"\"use strict\";\nvar nwmatcher = require(\"nwmatcher/src/nwmatcher-noqsa\");\nvar memoizeQuery = require(\"../utils\").memoizeQuery;\n\nmodule.exports = function (core) {\n  [core.Document, core.DocumentFragment, core.Element].forEach(function (Class) {\n    Class.prototype.querySelector = memoizeQuery(function (selectors) {\n      return addNwmatcher(this).first(String(selectors), this);\n    });\n\n    Class.prototype.querySelectorAll = memoizeQuery(function (selectors) {\n      return new core.NodeList(addNwmatcher(this).select(String(selectors), this));\n    });\n  });\n\n  core.Element.prototype.matches = memoizeQuery(function (selectors) {\n    return addNwmatcher(this).match(this, selectors);\n  });\n};\n\n// nwmatcher gets `document.documentElement` at creation-time, so we have to initialize lazily, since in the initial\n// stages of Document initialization, there is no documentElement present yet.\nfunction addNwmatcher(parentNode) {\n  var document = parentNode._ownerDocument;\n\n  if (!document._nwmatcher) {\n    document._nwmatcher = nwmatcher({ document: document });\n    document._nwmatcher.configure({ UNIQUE_ID: false });\n  }\n\n  return document._nwmatcher;\n}\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/index.js":"var HtmlToDom     = require('./htmltodom').HtmlToDom,\n    jsdom         = require('../../jsdom'),\n    defineGetter  = require('../utils').defineGetter,\n    defineSetter  = require('../utils').defineSetter,\n    Contextify    = require('contextify'),\n    Window        = require('./Window');\n\nfunction windowAugmentation(document) {\n  var window = createWindow(document);\n\n  if (document.addEventListener) {\n    if (document.readyState == 'complete') {\n      var ev = document.createEvent('HTMLEvents');\n      ev.initEvent('load', false, false);\n      process.nextTick(function () {\n        window.dispatchEvent(ev);\n      });\n    }\n    else {\n      document.addEventListener('load', function(ev) {\n        window.dispatchEvent(ev);\n      });\n    }\n  }\n\n  return window;\n};\n\nfunction createWindow(document) {\n  var window = new Window(document);\n\n  Contextify(window);\n\n  // We need to set up self references using Contextify's getGlobal() so that\n  // the global object identity is correct (window === this).\n  // See Contextify README for more info.\n  var windowGlobal = window.getGlobal();\n\n  // Set up the window as if it's a top level window.\n  // If it's not, then references will be corrected by frame/iframe code.\n  // Note: window.frames is maintained in the HTMLFrameElement init function.\n  window.window = window.frames\n                = window.self\n                = window.parent\n                = window.top = windowGlobal;\n\n  return window;\n};\n\n/**\n * Augments the given DOM by adding browser-specific properties and methods (BOM).\n * Returns the augmented DOM.\n */\n// TODO: this function is HORIBBLE. It modifies the *shared* `dom` variable with document-specific stuff.\n// We call it in `jsdom.jsdom`, i.e. per-document. The checks `if (dom._augment && ...)` just mean that it won't modify\n// the global twice *for the same options*. Bad stuff.\n//\n// None of the properties set here should be on `dom`, really.\nexports.browserAugmentation = function (dom, options) {\n  if (!options) {\n    options = {};\n  }\n\n  var parser = options.parser;\n\n  if (dom._augmented && dom._parser === parser && dom._parsingMode === options.parsingMode) {\n    return dom;\n  }\n\n  dom._parser = parser;\n  dom._parsingMode = options.parsingMode;\n  var htmltodom = new HtmlToDom(parser, options.parsingMode);\n  dom.Document.prototype._htmlToDom = htmltodom;\n  dom.Document.prototype._domImpl = dom.DOMImplementation;\n\n  defineGetter(dom.Document.prototype, 'parentWindow', function() {\n    if (!this._parentWindow) {\n      this.parentWindow = windowAugmentation(this);\n    }\n    return this._parentWindow;\n  });\n\n  dom._augmented = true;\n  return dom;\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/Window.js":"\"use strict\";\n\nvar URL = require(\"url\");\nvar CSSStyleDeclaration = require(\"cssstyle\").CSSStyleDeclaration;\nvar XMLHttpRequest = require(\"xmlhttprequest\").XMLHttpRequest;\nvar dom = require(\"../level1/core\");\nvar NOT_IMPLEMENTED = require(\"./utils\").NOT_IMPLEMENTED;\nvar createFrom = require(\"../utils\").createFrom;\nvar History = require(\"./history\");\nvar VirtualConsole = require(\"../virtual-console\");\n\nvar cssSelectorSplitRE = /((?:[^,\"']|\"[^\"]*\"|'[^']*')+)/;\n\nfunction matchesDontThrow(el, selector) {\n  try {\n    return el.matches(selector);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction startTimer(window, startFn, stopFn, callback, ms) {\n  var res = startFn(callback, ms);\n  window.__timers.push([res, stopFn]);\n  return res;\n}\n\nfunction stopTimer(window, id) {\n  if (typeof id === \"undefined\") {\n    return;\n  }\n  for (var i in window.__timers) {\n    if (window.__timers[i][0] === id) {\n      window.__timers[i][1].call(window, id);\n      window.__timers.splice(i, 1);\n      break;\n    }\n  }\n}\n\nfunction stopAllTimers(window) {\n  window.__timers.forEach(function (t) {\n    t[1].call(window, t[0]);\n  });\n  window.__timers = [];\n}\n\nfunction Window(document) {\n  this.__timers = [];\n\n  // TODO: very little of this belongs on the instance; they should be prototype methods instead.\n\n  var window = this;\n  this._document = document;\n  this.history = new History(this);\n\n  this.addEventListener = function () {\n    dom.Node.prototype.addEventListener.apply(window, arguments);\n  };\n  this.removeEventListener = function () {\n    dom.Node.prototype.removeEventListener.apply(window, arguments);\n  };\n  this.dispatchEvent = function () {\n    dom.Node.prototype.dispatchEvent.apply(window, arguments);\n  };\n  this.raise = function () {\n    dom.Node.prototype.raise.apply(window.document, arguments);\n  };\n\n  this.setTimeout = function (fn, ms) { return startTimer(window, setTimeout, clearTimeout, fn, ms); };\n  this.setInterval = function (fn, ms) { return startTimer(window, setInterval, clearInterval, fn, ms); };\n  this.clearInterval = stopTimer.bind(this, window);\n  this.clearTimeout = stopTimer.bind(this, window);\n  this.__stopAllTimers = stopAllTimers.bind(this, window);\n  this.Image = function (width, height) {\n    var element = window._document.createElement(\"img\");\n    element.width = width;\n    element.height = height;\n    return element;\n  };\n\n  this._virtualConsole = new VirtualConsole();\n\n  function wrapConsoleMethod(method) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      window._virtualConsole.emit.apply(window._virtualConsole, [method].concat(args));\n    };\n  }\n\n  this.console = {\n    assert: wrapConsoleMethod(\"assert\"),\n    clear: wrapConsoleMethod(\"clear\"),\n    count: wrapConsoleMethod(\"count\"),\n    debug: wrapConsoleMethod(\"debug\"),\n    error: wrapConsoleMethod(\"error\"),\n    group: wrapConsoleMethod(\"group\"),\n    groupCollapse: wrapConsoleMethod(\"groupCollapse\"),\n    groupEnd: wrapConsoleMethod(\"groupEnd\"),\n    info: wrapConsoleMethod(\"info\"),\n    log: wrapConsoleMethod(\"log\"),\n    table: wrapConsoleMethod(\"table\"),\n    time: wrapConsoleMethod(\"time\"),\n    timeEnd: wrapConsoleMethod(\"timeEnd\"),\n    trace: wrapConsoleMethod(\"trace\"),\n    warn: wrapConsoleMethod(\"warn\")\n  };\n\n  this.XMLHttpRequest = function () {\n    var xhr = new XMLHttpRequest();\n    var lastUrl = \"\";\n    xhr._open = xhr.open;\n    xhr.open = function (method, url, async, user, password) {\n      url = URL.resolve(window.document.URL, url);\n      lastUrl = url;\n      return xhr._open(method, url, async, user, password);\n    };\n    xhr._send = xhr.send;\n    xhr.send = function (data) {\n      if (window.document.cookie) {\n        var cookieDomain = window.document._cookieDomain;\n        var url = URL.parse(lastUrl);\n        var host = url.host.split(\":\")[0];\n        if (host.indexOf(cookieDomain, host.length - cookieDomain.length) !== -1) {\n          xhr.setDisableHeaderCheck(true);\n          xhr.setRequestHeader(\"cookie\", window.document.cookie);\n          xhr.setDisableHeaderCheck(false);\n        }\n      }\n      return xhr._send(data);\n    };\n    return xhr;\n  };\n}\n\nWindow.prototype = createFrom(dom || null, {\n  constructor: Window,\n  // This implements window.frames.length, since window.frames returns a\n  // self reference to the window object.  This value is incremented in the\n  // HTMLFrameElement init function (see: level2/html.js).\n  _length: 0,\n  get length() {\n    return this._length;\n  },\n  get document() {\n    return this._document;\n  },\n  get location() {\n    return this._document._location;\n  },\n  close: function () {\n    // Recursively close child frame windows, then ourselves.\n    var currentWindow = this;\n    (function windowCleaner(window) {\n      var i;\n      // We could call window.frames.length etc, but window.frames just points\n      // back to window.\n      if (window.length > 0) {\n        for (i = 0; i < window.length; i++) {\n          windowCleaner(window[i]);\n        }\n      }\n      // We\"re already in our own window.close().\n      if (window !== currentWindow) {\n        window.close();\n      }\n    })(this);\n\n    if (this._document) {\n      if (this._document.body) {\n        this._document.body.innerHTML = \"\";\n      }\n\n      if (this._document.close) {\n        // We need to empty out the event listener array because\n        // document.close() causes \"load\" event to re-fire.\n        this._document._listeners = [];\n        this._document.close();\n      }\n      delete this._document;\n    }\n\n    stopAllTimers(currentWindow);\n    // Clean up the window\"s execution context.\n    // dispose() is added by Contextify.\n    this.dispose();\n  },\n  getComputedStyle: function (node) {\n    var s = node.style,\n        cs = new CSSStyleDeclaration(),\n        forEach = Array.prototype.forEach;\n\n    function setPropertiesFromRule(rule) {\n      if (!rule.selectorText) {\n        return;\n      }\n\n      var selectors = rule.selectorText.split(cssSelectorSplitRE);\n      var matched = false;\n      selectors.forEach(function (selectorText) {\n        if (selectorText !== \"\" && selectorText !== \",\" && !matched && matchesDontThrow(node, selectorText)) {\n          matched = true;\n          forEach.call(rule.style, function (property) {\n            cs.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));\n          });\n        }\n      });\n    }\n\n    forEach.call(node.ownerDocument.styleSheets, function (sheet) {\n      forEach.call(sheet.cssRules, function (rule) {\n        if (rule.media) {\n          if (Array.prototype.indexOf.call(rule.media, \"screen\") !== -1) {\n            forEach.call(rule.cssRules, setPropertiesFromRule);\n          }\n        } else {\n          setPropertiesFromRule(rule);\n        }\n      });\n    });\n\n    forEach.call(s, function (property) {\n      cs.setProperty(property, s.getPropertyValue(property), s.getPropertyPriority(property));\n    });\n\n    return cs;\n  },\n\n  // TODO: all of the below data properties should be getters; right now they are shared between Window instances\n  // which is of course bad.\n  navigator: {\n    get userAgent() { return \"Node.js (\" + process.platform + \"; U; rv:\" + process.version + \")\"; },\n    get appName() { return \"Node.js jsDom\"; },\n    get platform() { return process.platform; },\n    get appVersion() { return process.version; },\n    noUI: true,\n    get cookieEnabled() { return true; }\n  },\n\n  name: \"nodejs\",\n  innerWidth: 1024,\n  innerHeight: 768,\n  outerWidth: 1024,\n  outerHeight: 768,\n  pageXOffset: 0,\n  pageYOffset: 0,\n  screenX: 0,\n  screenY: 0,\n  screenLeft: 0,\n  screenTop: 0,\n  scrollX: 0,\n  scrollY: 0,\n  scrollTop: 0,\n  scrollLeft: 0,\n  alert: NOT_IMPLEMENTED(\"window.alert\"),\n  blur: NOT_IMPLEMENTED(\"window.blur\"),\n  confirm: NOT_IMPLEMENTED(\"window.confirm\"),\n  createPopup: NOT_IMPLEMENTED(\"window.createPopup\"),\n  focus: NOT_IMPLEMENTED(\"window.focus\"),\n  moveBy: NOT_IMPLEMENTED(\"window.moveBy\"),\n  moveTo: NOT_IMPLEMENTED(\"window.moveTo\"),\n  open: NOT_IMPLEMENTED(\"window.open\"),\n  print: NOT_IMPLEMENTED(\"window.print\"),\n  prompt: NOT_IMPLEMENTED(\"window.prompt\"),\n  resizeBy: NOT_IMPLEMENTED(\"window.resizeBy\"),\n  resizeTo: NOT_IMPLEMENTED(\"window.resizeTo\"),\n  scroll: NOT_IMPLEMENTED(\"window.scroll\"),\n  scrollBy: NOT_IMPLEMENTED(\"window.scrollBy\"),\n  scrollTo: NOT_IMPLEMENTED(\"window.scrollTo\"),\n  screen: {\n    width: 0,\n    height: 0\n  },\n\n  // Note: these will not be necessary for newer Node.js versions, which have\n  // typed arrays in V8 and thus on every global object. (That is, in newer\n  // versions we\"ll get `ArrayBuffer` just as automatically as we get\n  // `Array`.) But to support older versions, we explicitly set them here.\n  Int8Array: global.Int8Array,\n  Int16Array: global.Int16Array,\n  Int32Array: global.Int32Array,\n  Float32Array: global.Float32Array,\n  Float64Array: global.Float64Array,\n  Uint8Array: global.Uint8Array,\n  Uint8ClampedArray: global.Uint8ClampedArray,\n  Uint16Array: global.Uint16Array,\n  Uint32Array: global.Uint32Array,\n  ArrayBuffer: global.ArrayBuffer\n});\n\nmodule.exports = Window;\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/browser/history.js":"\"use strict\";\nvar URL = require(\"url\");\nvar resolveHref = require(\"../utils\").resolveHref;\n\nfunction StateEntry(data, title, url) {\n  this.data = data;\n  this.title = title;\n  this.url = url;\n}\n\nmodule.exports = History;\n\nfunction History(window) {\n  this._states = [new StateEntry(null, \"\", window.location._url.href)];\n  this._index = 0;\n  this._window = window;\n  this._location = window.location;\n}\n\nHistory.prototype = {\n  constructor: History,\n\n  get length() {\n    return this._states.length;\n  },\n\n  get state() {\n    var state = this._states[this._index];\n    return state ? state.data : null;\n  },\n\n  back: function () {\n    this.go(-1);\n  },\n\n  forward: function () {\n    this.go(1);\n  },\n\n  go: function (delta) {\n    if (typeof delta === \"undefined\" || delta === 0) {\n      this._location.reload();\n      return;\n    }\n\n    var newIndex = this._index + delta;\n\n    if (newIndex < 0 || newIndex >= this.length) {\n      return;\n    }\n\n    this._index = newIndex;\n\n    var state = this._states[newIndex];\n\n    this._applyState(state);\n    this._signalPopstate(state);\n  },\n\n  pushState: function (data, title, url) {\n    var state = new StateEntry(data, title, url);\n    if (this._index + 1 !== this._states.length) {\n      this._states = this._states.slice(0, this._index + 1);\n    }\n    this._states.push(state);\n    this._applyState(state);\n    this._index++;\n  },\n\n  replaceState: function (data, title, url) {\n    var state = new StateEntry(data, title, url);\n    this._states[this._index] = state;\n    this._applyState(state);\n  },\n\n  _applyState: function (state) {\n    this._location._url = URL.parse(resolveHref(this._location._url.href, state.url));\n  },\n\n  _signalPopstate: function(state) {\n    if (this._window.document) {\n      var ev = this._window.document.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"popstate\", false, false);\n      ev.state = state.data;\n      process.nextTick(function () {\n        this._window.dispatchEvent(ev);\n      }.bind(this));\n    }\n  },\n\n  toString: function () {\n    return \"[object History]\";\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-jsdom/node_modules/node-jsdom/lib/jsdom/virtual-console.js":"\"use strict\";\n\nvar EventEmitter = require(\"events\").EventEmitter;\nvar utils = require(\"./utils\");\n\nfunction VirtualConsole() {\n  // If \"error\" event has no listeners,\n  // EventEmitter throws an exception\n  this.on(\"error\", function () {});\n}\n\nutils.inheritFrom(EventEmitter, VirtualConsole, {\n  sendTo: function (anyConsole) {\n    Object.keys(anyConsole).forEach(function (method) {\n      if (typeof anyConsole[method] === \"function\") {\n        this.on(method, function () {\n          anyConsole[method].apply(anyConsole, arguments);\n        });\n      }\n    }, this);\n  }\n});\n\nmodule.exports = VirtualConsole;\n"}